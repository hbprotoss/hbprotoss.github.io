<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>hbprotoss的博客 | hbprotoss的博客</title>

    
            <link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">

    
            <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">

      <link rel="canonical" href="http://hbprotoss.github.io/index.html">



    
        <!--[if lt IE 9]><script src="/assets/js/html5.js"></script><![endif]-->

    




</head>
<body>
    <section class="social">
        <ul>
        
            <li><a href="#" title="Home"><i class="icon-home"></i></a></li>
            <li><a href="archive.html" title="Archives"><i class="icon-folder-open-alt"></i></a></li>
            <li><a href="categories/index.html" title="Tags"><i class="icon-tags"></i></a></li>
            <li><a href="rss.xml" title="RSS"><i class="icon-rss"></i></a></li>
            <li><a href="https://twitter.com/hbprotoss" title="My Twitter"><i class="icon-twitter"></i></a></li>
            <li><a href="https://github.com/hbprotoss" title="My Github"><i class="icon-github"></i></a></li>
            <li><a href="http://getnikola.com" title="About me"><i class="icon-user"></i></a></li>

        </ul>
    </section>
    <section class="page-content">
        <div class="content" rel="main">
            
        <div class="post">
            <h1 class="title"><a href="posts/innodbyin-qing-suo-yin-xue-xi-bi-ji.html">InnoDB引擎索引学习笔记</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2013-11-16T19:31:34+08:00">2013-11-16 19:31</time>
                </div>
                <div class="stats">
                    
        
    <a href="posts/innodbyin-qing-suo-yin-xue-xi-bi-ji.html#disqus_thread" data-disqus-identifier="cache/posts/innodbyin-qing-suo-yin-xue-xi-bi-ji.html">Comments</a>


                </div>
            
        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/database.html" rel="tag">Database</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<p>最近在研究学习MySQL，本文记录下索引相关（主要B-Tree索引）的特性。</p>
<hr>
<h3>索引是什么</h3>
<p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。</p>
<p>按所用的数据结构分，有B-Tree索引（B+ Tree）、哈希索引、R-Tree索引等。按数据块的顺序和索引节点的逻辑顺序是否一致可以分为聚集索引和非聚集索引。聚集索引由于物理块连续，在范围扫描的时候可以减少磁头寻道时间，因而比非聚集索引高效。</p>
<h3>InnoDB索引结构</h3>
<p>InnoDB引擎的索引主体结构是B+Tree（这种数据结构的描述可以参考CSDN博主v_JULY_v的<a href="http://blog.csdn.net/v_JULY_v/article/details/6530142">从B树、B+树、B*树谈到R 树</a>）。</p>
<p>其中，主键索引(Primary Index)是聚集索引，中间节点是用于查询的边界值，叶子节点就是数据节点，叶子节点之间通过指针形成双向链表。如图：</p>
<p><img alt="primary_index.jpg" src="galleries/InnoDB/primary_index.jpg" title=""></p>
<p>辅助索引(Secondary Index)同样为B-Tree索引，只是叶子节点不是数据节点，而是对主键的引用。</p>
<p><img alt="secondary_index.jpg" src="galleries/InnoDB/secondary_index.jpg" title=""></p>
<p>由于此特性，InnoDB引擎要求数据表必须有一个主键，如果没有主键，在数据表创建的时候会自动生成一个唯一非空索引替代。这个特性也决定了InnoDB表的主键最好是一个自增的ID序列，这样在后续插入的过程中不会造成数据块的唯一，提升性能。</p>
<p>当所建立的索引为多列索引的时候，例如KEY(a,b,c)，中间节点依旧以最左边的一列a进行索引，只是在叶子节点上保存的不仅仅是a，而是(a,b,c)多字段排序后的序列。</p>
<h3>性能实测</h3>
<p>下面结合实际例子阐述现象和内部结构的关系</p>
<p>首先建立一个测试表：</p>
<pre class="code literal-block"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">test</span> <span class="p">(</span>
     <span class="n">id</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
     <span class="n">a</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
     <span class="n">b</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
     <span class="k">c</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
     <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
     <span class="k">KEY</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="k">c</span><span class="p">)</span>
<span class="p">)</span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>
</pre>


<p>数据项为(a,b,c)在0~200之间的所有组合项，共计8000000行记录。为了消除几次实验中以query cache为代表的各种server cache对实验数据的影响，每次实验后均重启mysql服务。</p>
<h4>索引对查询效率的影响</h4>
<p>首先是建立KEY(a,b,c)索引前后的性能对比，能很明显地看到索引大幅提升查询速度。没有索引的时候需要做全表扫描，建立索引之后通过B-Tree搜索。</p>
<pre class="code literal-block"><span class="err">没有索引（除主键，下同）</span>
<span class="p">[</span><span class="n">SQL</span><span class="p">]</span><span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">test</span> <span class="n">where</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">and</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">Affected</span> <span class="n">rows</span><span class="o">:</span> <span class="mi">0</span>
<span class="nl">Time:</span> <span class="mf">0.324</span><span class="n">s</span>

<span class="err">建立</span><span class="n">KEY</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
<span class="p">[</span><span class="n">SQL</span><span class="p">]</span><span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">test</span> <span class="n">where</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">and</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">Affected</span> <span class="n">rows</span><span class="o">:</span> <span class="mi">0</span>
<span class="nl">Time:</span> <span class="mf">0.004</span><span class="n">s</span>
</pre>


<p>由于MySQL优化器的优化，where条件中的各个子条件顺序对索引的使用没有影响。</p>
<pre class="code literal-block"><span class="p">[</span><span class="n">SQL</span><span class="p">]</span><span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">test</span> <span class="n">where</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">and</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Affected</span> <span class="n">rows</span><span class="o">:</span> <span class="mi">0</span>
<span class="nl">Time:</span> <span class="mf">0.002</span><span class="n">s</span>
</pre>


<p>当使用的列非严格的索引最左前缀时，可以想象，只有a加速了索引搜索，找到所有符合a条件的记录的之后只能顺序扫描检查c是否符合条件。所以相比没有索引时要快，但是慢于使用严格索引最左前缀时的速度。</p>
<pre class="code literal-block"><span class="p">[</span><span class="n">SQL</span><span class="p">]</span><span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">test</span> <span class="n">where</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">and</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">Affected</span> <span class="n">rows</span><span class="o">:</span> <span class="mi">0</span>
<span class="nl">Time:</span> <span class="mf">0.043</span><span class="n">s</span>
</pre>


<p>当没有使用到a列作为条件时完全没法使用索引，甚至比没有索引时还要慢。因为建表的时候a在前，b、c在后，并且数据节点有序。在没有索引的测试中，InnoDB引擎到a不为0时自动停止搜索。而在这个例子中需要扫描全表找出满足符合条件的b、c，达到完全没法忍受的16秒。</p>
<pre class="code literal-block"><span class="p">[</span><span class="n">SQL</span><span class="p">]</span><span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">test</span> <span class="n">where</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">and</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">Affected</span> <span class="n">rows</span><span class="o">:</span> <span class="mi">0</span>
<span class="nl">Time:</span> <span class="mf">16.023</span><span class="n">s</span>
</pre>


<h4>索引对排序效率的影响</h4>
<p>只要能用到索引，并且ORDER BY后面的列在索引中，则顺序还是倒序排序对性能无影响。因为叶子节点是个双向链表，倒序可以从后向前遍历，与顺序的代价相同。</p>
<pre class="code literal-block"><span class="p">[</span><span class="n">SQL</span><span class="p">]</span><span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">test</span> <span class="n">where</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">ORDER</span> <span class="n">BY</span> <span class="n">b</span><span class="p">;</span>
<span class="n">Affected</span> <span class="n">rows</span><span class="o">:</span> <span class="mi">0</span>
<span class="nl">Time:</span> <span class="mf">0.085</span><span class="n">s</span>

<span class="p">[</span><span class="n">SQL</span><span class="p">]</span><span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">test</span> <span class="n">where</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">ORDER</span> <span class="n">BY</span> <span class="n">b</span> <span class="n">DESC</span><span class="p">;</span>
<span class="n">Affected</span> <span class="n">rows</span><span class="o">:</span> <span class="mi">0</span>
<span class="nl">Time:</span> <span class="mf">0.089</span><span class="n">s</span>
</pre>


<p>但是，当有两个字段排序的顺序不同时，叶子节点的有序性就无法用在排序中，必须读出所有叶子节点之后再按指定的字段进行一趟排序，所以速度就慢了下来。</p>
<pre class="code literal-block"><span class="p">[</span><span class="n">SQL</span><span class="p">]</span><span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">test</span> <span class="n">where</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">ORDER</span> <span class="n">BY</span> <span class="n">b</span> <span class="n">DESC</span><span class="p">,</span> <span class="n">c</span> <span class="n">DESC</span><span class="p">;</span>
<span class="n">Affected</span> <span class="n">rows</span><span class="o">:</span> <span class="mi">0</span>
<span class="nl">Time:</span> <span class="mf">0.089</span><span class="n">s</span>

<span class="p">[</span><span class="n">SQL</span><span class="p">]</span><span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">test</span> <span class="n">where</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">ORDER</span> <span class="n">BY</span> <span class="n">b</span> <span class="n">ASC</span><span class="p">,</span> <span class="n">c</span> <span class="n">DESC</span><span class="p">;</span>
<span class="n">Affected</span> <span class="n">rows</span><span class="o">:</span> <span class="mi">0</span>
<span class="nl">Time:</span> <span class="mf">0.184</span><span class="n">s</span>
</pre>


<p>同样，下面的例子中对索引左边的字段a进行范围选择的时候也没法运用索引，因为多个取值的a无法保证b和c字段有序，必须重新排序</p>
<pre class="code literal-block"><span class="p">[</span><span class="n">SQL</span><span class="p">]</span><span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">test</span> <span class="n">where</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="n">ORDER</span> <span class="n">BY</span> <span class="n">b</span><span class="p">;</span>
<span class="n">Affected</span> <span class="n">rows</span><span class="o">:</span> <span class="mi">0</span>
<span class="nl">Time:</span> <span class="mf">0.103</span><span class="n">s</span>
</pre>


<p>所以，尽可能做到覆盖索引（即where，order by中用到的字段被索引覆盖），能利用索引加速搜索和排序。</p>
<hr>
<p>参考资料：</p>
<p>《高性能MySQL》，电子工业出版社，2010年1月</p>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/pythonla-ji-hui-shou-ji-zhi.html">Python垃圾回收机制</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2013-10-24T10:44:52+08:00">2013-10-24 10:44</time>
                </div>
                <div class="stats">
                    
        
    <a href="posts/pythonla-ji-hui-shou-ji-zhi.html#disqus_thread" data-disqus-identifier="cache/posts/pythonla-ji-hui-shou-ji-zhi.html">Comments</a>


                </div>
            

            </div>
            <div class="body">
                <div>
<p>题记：我是来填坑的。。。</p>
<p>本文主要结合CPython源码分析一下Python的GC机制（面试的时候被问到这个问题，之前理解不深，答得不好，一波大坑啊。。。）</p>
<hr>
<p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p>
<h3>引用计数</h3>
<p>引用计数法在对象内部维护了一个被其他对象引用数的引用计数值，当这个引用计数值为0时，说明这个对象不再被其他对象引用，就可以被回收了。</p>
<p>结合源码来看，所有Python对象的头部包含了这样一个结构PyObject（相当于继承自PyObject）：</p>
<pre class="code literal-block"><span class="c1">// object.h</span>
<span class="k">struct</span> <span class="n">_object</span> <span class="p">{</span>
    <span class="n">Py_ssize_t</span> <span class="n">ob_refcnt</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">ob_type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyObject</span><span class="p">;</span>
</pre>


<p>ob_refcnt就是引用计数值。</p>
<p>例如，下面是int型对象的定义：</p>
<pre class="code literal-block"><span class="c1">// intobject.h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">PyObject_HEAD</span>
        <span class="kt">long</span> <span class="n">ob_ival</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyIntObject</span><span class="p">;</span>
</pre>


<p>引用计数法有很明显的优点：</p>
<ol>
<li>高效</li>
<li>运行期没有停顿</li>
<li>对象有确定的生命周期</li>
<li>易于实现</li>
</ol>
<p>原始的引用计数法也有明显的缺点：</p>
<ol>
<li>维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。</li>
<li>无法解决循环引用的问题。A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数都为1，但显然应该被回收。</li>
</ol>
<p>为了解决这两个致命弱点，Python又引入了以下两种GC机制。</p>
<h3>标记-清除</h3>
<p>“标记-清除”法是为了解决循环引用问题。可以包含其他对象引用的容器对象（如list, dict, set，甚至class）都可能产生循环引用，为此，在申请内存时，所有容器对象的头部又加上了<code>PyGC_Head</code>来实现“标记-清除”机制。</p>
<pre class="code literal-block"><span class="c1">// objimpl.h</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">_gc_head</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="k">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_next</span><span class="p">;</span>
        <span class="k">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_prev</span><span class="p">;</span>
        <span class="n">Py_ssize_t</span> <span class="n">gc_refs</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">gc</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">double</span> <span class="n">dummy</span><span class="p">;</span>  <span class="cm">/* force worst-case alignment */</span>
<span class="p">}</span> <span class="n">PyGC_Head</span><span class="p">;</span>
</pre>


<p>在为对象申请内存的时候，可以明显看到，实际申请的内存数量已经加上了PyGC_Head的大小</p>
<pre class="code literal-block"><span class="c1">// gcmodule.c</span>
<span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">_PyObject_GC_Malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">basicsize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="p">)</span><span class="n">PyObject_MALLOC</span><span class="p">(</span>
                <span class="k">sizeof</span><span class="p">(</span><span class="n">PyGC_Head</span><span class="p">)</span> <span class="o">+</span> <span class="n">basicsize</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">g</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>

    <span class="p">......</span>

    <span class="n">op</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>举例来说，从<code>list</code>对象的创建中，有如下主要逻辑：</p>
<pre class="code literal-block"><span class="c1">// listobject.c</span>
<span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyList_New</span><span class="p">(</span><span class="n">Py_ssize_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyListObject</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
    <span class="p">......</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">PyObject_GC_New</span><span class="p">(</span><span class="n">PyListObject</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PyList_Type</span><span class="p">);</span>
    <span class="p">......</span>
    <span class="n">_PyObject_GC_TRACK</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p><code>_PyObject_GC_TRACK</code>就将对象链接到了第0代对象集合中（后文详述分代回收）。</p>
<p>垃圾标记时，先将集合中对象的引用计数复制一份副本(以免在操作过程中破坏真实的引用计数值)：</p>
<pre class="code literal-block"><span class="c1">// gcmodule.c</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">update_refs</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">containers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">containers</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">gc</span> <span class="o">!=</span> <span class="n">containers</span><span class="p">;</span> <span class="n">gc</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">==</span> <span class="n">GC_REACHABLE</span><span class="p">);</span>
        <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ob_refcnt</span><span class="p">;</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>


<p>然后操作这个副本，遍历对象集合，将被引用对象的引用计数副本值减1：</p>
<pre class="code literal-block"><span class="c1">// gcmodule.c</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">subtract_refs</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">containers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">traverseproc</span> <span class="n">traverse</span><span class="p">;</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">containers</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">gc</span> <span class="o">!=</span> <span class="n">containers</span><span class="p">;</span> <span class="n">gc</span><span class="o">=</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">traverse</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_traverse</span><span class="p">;</span>
        <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">traverse</span><span class="p">(</span><span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">),</span>
                   <span class="p">(</span><span class="n">visitproc</span><span class="p">)</span><span class="n">visit_decref</span><span class="p">,</span>
                   <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>


<p>这个<code>traverse</code>是对象类型定义的函数，用来遍历对象，通过传入的回调函数<code>visit_decref</code>来操作引用计数副本。</p>
<p>例如<code>dict</code>就要在key和value上都用<code>visit_decref</code>操作一遍：</p>
<pre class="code literal-block"><span class="c1">// dictobject.c</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">dict_traverse</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_ssize_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">pk</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">pv</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">PyDict_Next</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pv</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">visit</span><span class="p">(</span><span class="n">pk</span><span class="p">);</span>
        <span class="n">visit</span><span class="p">(</span><span class="n">pv</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>然后根据引用计数副本值是否为0将集合内的对象分成两类，reachable和unreachable，其中unreachable是可以被回收的对象：</p>
<pre class="code literal-block"><span class="c1">// gcmodule.c</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">move_unreachable</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">young</span><span class="p">,</span> <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">unreachable</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">young</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">gc</span> <span class="o">!=</span> <span class="n">young</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">);</span>
            <span class="n">traverseproc</span> <span class="n">traverse</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_traverse</span><span class="p">;</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">GC_REACHABLE</span><span class="p">;</span>
            <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">traverse</span><span class="p">(</span><span class="n">op</span><span class="p">,</span>
                            <span class="p">(</span><span class="n">visitproc</span><span class="p">)</span><span class="n">visit_reachable</span><span class="p">,</span>
                            <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">young</span><span class="p">);</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
            <span class="n">gc_list_move</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">unreachable</span><span class="p">);</span>
            <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">GC_TENTATIVELY_UNREACHABLE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">gc</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>


<p>在处理了weak reference和finalizer等琐碎细节后（本文不展开讲述，有兴趣的童鞋请参考python源码），就可以回收unreachable中的对象了。</p>
<h3>分代回收</h3>
<p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p>
<p>用来表示“代”的结构体是<code>gc_generation</code>， 包括了当前代链表表头、对象数量上限、当前对象数量：</p>
<pre class="code literal-block"><span class="c1">// gcmodule.c</span>
<span class="k">struct</span> <span class="n">gc_generation</span> <span class="p">{</span>
    <span class="n">PyGC_Head</span> <span class="n">head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">threshold</span><span class="p">;</span> <span class="cm">/* collection threshold */</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span> <span class="cm">/* count of allocations or collections of younger</span>
<span class="cm">              generations */</span>
<span class="p">};</span>
</pre>


<p>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。</p>
<pre class="code literal-block"><span class="cp">#define NUM_GENERATIONS 3</span>
<span class="cp">#define GEN_HEAD(n) (&amp;generations[n].head)</span>

<span class="cm">/* linked lists of container objects */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gc_generation</span> <span class="n">generations</span><span class="p">[</span><span class="n">NUM_GENERATIONS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/* PyGC_Head,               threshold,  count */</span>
    <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>   <span class="mi">700</span><span class="p">,</span>        <span class="mi">0</span><span class="p">},</span>
    <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>   <span class="mi">10</span><span class="p">,</span>     <span class="mi">0</span><span class="p">},</span>
    <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>   <span class="mi">10</span><span class="p">,</span>     <span class="mi">0</span><span class="p">},</span>
<span class="p">};</span>
</pre>


<p>新生成的对象会被加入第0代，前面<code>_PyObject_GC_Malloc</code>中省略的部分就是Python GC触发的时机。每新生成一个对象都会检查第0代有没有满，如果满了就开始着手进行垃圾回收：</p>
<pre class="code literal-block"> <span class="n">g</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">GC_UNTRACKED</span><span class="p">;</span>
 <span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* number of allocated GC objects */</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&amp;&amp;</span>
     <span class="n">enabled</span> <span class="o">&amp;&amp;</span>
     <span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&amp;&amp;</span>
     <span class="o">!</span><span class="n">collecting</span> <span class="o">&amp;&amp;</span>
     <span class="o">!</span><span class="n">PyErr_Occurred</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">collecting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">collect_generations</span><span class="p">();</span>
          <span class="n">collecting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</pre>


<hr>
<p>参考资料：</p>
<ol>
<li>《Python源码剖析》，陈儒著，2008</li>
<li>Wikipedia - Reference counting: <a href="http://en.wikipedia.org/wiki/Reference_counting">http://en.wikipedia.org/wiki/Reference_counting</a>
</li>
<li>Wikipedia - Garbage collection: <a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</a>
</li>
</ol>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/li-yong-ld_preloadjin-xing-hook.html">利用LD_PRELOAD进行hook</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2013-10-09T11:44:50+08:00">2013-10-09 11:44</time>
                </div>
                <div class="stats">
                    
        
    <a href="posts/li-yong-ld_preloadjin-xing-hook.html#disqus_thread" data-disqus-identifier="cache/posts/li-yong-ld_preloadjin-xing-hook.html">Comments</a>


                </div>
            
        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/c.html" rel="tag">C</a></li>
           <li><a class="tag p-category" href="categories/hook.html" rel="tag">Hook</a></li>
           <li><a class="tag p-category" href="categories/linux.html" rel="tag">Linux</a></li>
           <li><a class="tag p-category" href="categories/security.html" rel="tag">Security</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<p>好久没玩hook这种猥琐的东西里，今天在Linux下体验了一把。</p>
<p>loader在进行动态链接的时候，会将有相同符号名的符号覆盖成LD_PRELOAD指定的so文件中的符号。换句话说，可以用我们自己的so库中的函数替换原来库里有的函数，从而达到hook的目的。这和Windows下通过修改import table来hook API很类似。相比较之下，LD_PRELOAD更方便了，都不用自己写代码了，系统的loader会帮我们搞定。但是LD_PRELOAD有个限制：只能hook动态链接的库，对静态链接的库无效，因为静态链接的代码都写到可执行文件里了嘛，没有坑让你填。</p>
<p>上代码</p>
<p>先是受害者，我们的主程序main.c，通过strcmp比较字符串是否相等：</p>
<pre class="code literal-block"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"test"</span><span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Incorrect password</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Correct password</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>然后是用来hook的库hook.c：</p>
<pre class="code literal-block"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;dlfcn.h&gt;</span>

<span class="k">typedef</span> <span class="nf">int</span><span class="p">(</span><span class="o">*</span><span class="n">STRCMP</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">strcmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">STRCMP</span> <span class="n">old_strcmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">handle</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="s">"libc.so.6"</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
        <span class="n">old_strcmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">STRCMP</span><span class="p">)</span><span class="n">dlsym</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">"strcmp"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hack function invoked. s1=&lt;%s&gt; s2=&lt;%s&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">old_strcmp</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>
<span class="p">}</span>
</pre>


<p>因为hook的目标是strcmp，所以typedef了一个STRCMP函数指针。由于hook的目的是要控制函数行为，所以需要从原库libc.so.6中拿到“正版”strcmp指针，保存成old_strcmp以备调用。</p>
<p>Makefile：</p>
<pre class="code literal-block"><span class="nb">test</span>: main.c hook.so
    gcc -o <span class="nb">test </span>main.c

hook.so: hook.c
    gcc -fPIC -shared -o hook.so hook.c -ldl
</pre>


<p>执行：</p>
<pre class="code literal-block"><span class="nv">$ LD_PRELOAD</span><span class="o">=</span>./hook.so ./test 123
hack <span class="k">function </span>invoked. <span class="nv">s1</span><span class="o">=</span>&lt;123&gt; <span class="nv">s2</span><span class="o">=</span>&lt;<span class="nb">test</span>&gt;
Incorrect password

<span class="nv">$ LD_PRELOAD</span><span class="o">=</span>./hook.so ./test <span class="nb">test</span>
hack <span class="k">function </span>invoked. <span class="nv">s1</span><span class="o">=</span>&lt;<span class="nb">test</span>&gt; <span class="nv">s2</span><span class="o">=</span>&lt;<span class="nb">test</span>&gt;
Correct password
</pre>


<p>其中有一点不理解的是，<code>dlopen</code>打开libc.so.6能拿到“正版”strcmp地址，打开libc.so就是hook后的地址。照理说libc.so不是libc.so.6的一个软链吗？为什么结果会不一样嘞？</p>
<hr>
<p>参考资料：</p>
<p><a href="http://www.exploit-db.com/papers/13233/">Reverse Engineering with LD_PRELOAD</a></p>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/linuxxia-bian-yi-lian-jie-dong-tai-ku.html">Linux下编译链接动态库</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2013-10-08T09:18:31+08:00">2013-10-08 09:18</time>
                </div>
                <div class="stats">
                    
        
    <a href="posts/linuxxia-bian-yi-lian-jie-dong-tai-ku.html#disqus_thread" data-disqus-identifier="cache/posts/linuxxia-bian-yi-lian-jie-dong-tai-ku.html">Comments</a>


                </div>
            
        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/c.html" rel="tag">C</a></li>
           <li><a class="tag p-category" href="categories/linux.html" rel="tag">Linux</a></li>
           <li><a class="tag p-category" href="categories/programming.html" rel="tag">Programming</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<p>记录下Linux下编译和链接动态库的过程。</p>
<h3>一、 编写动态库</h3>
<p>头文件so.h：  </p>
<pre class="code literal-block"><span class="cp">#ifndef  SO_H</span>
<span class="cp">#define  SO_H</span>

<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>


<span class="cp">#endif  </span><span class="cm">/*SO_H*/</span><span class="cp"></span>
</pre>


<p>实现文件so.c：</p>
<pre class="code literal-block"><span class="cp">#include "so.h"</span>

<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<h3>二、编译动态库</h3>
<pre class="code literal-block">gcc so.c -fPIC -shared -o libtest.so
</pre>


<p>解释一下各个参数含义：</p>
<ol>
<li>-fPIC：生成位置无关代码(<a href="http://en.wikipedia.org/wiki/Position-independent_code">Position Independent Code</a>)，只有生成PIC才能通过虚拟页映射达到可执行代码在进程间共享，从而节省内存的目的。</li>
<li>说明我们要生成的是动态库so(Shared Object)文件，从而进行动态链接。</li>
</ol>
<p>通过<code>nm -g libtest.so</code>可以看到，导出符号表中已经有<code>add</code>这个符号了：</p>
<pre class="code literal-block"><span class="nv">$ </span>nm -g libtest.so 
0000000000000670 T add
0000000000201030 B __bss_start
                 w __cxa_finalize@@GLIBC_2.2.5
0000000000201030 D _edata
0000000000201038 B _end
0000000000000684 T _fini
                 w __gmon_start__
0000000000000540 T _init
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
                 w _Jv_RegisterClasses
</pre>


<h3>三、使用动态库</h3>
<h4>1. 隐式链接(编译时链接)</h4>
<p>编写主程序main.c：</p>
<pre class="code literal-block"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include "so.h"</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>使用<code>gcc main.c -L. -ltest -o test</code>进行编译。</p>
<ul>
<li>-L：添加库文件的搜索路径</li>
<li>-l：指定需要链接的库。该名称是处在头lib和后缀.so中的名称，如上动态库libtest.so的l参数为-l test</li>
</ul>
<p>此时通过<code>readelf test -d</code>已经能看到生成的可执行文件test的Dynamic section里依赖libtest.so了</p>
<pre class="code literal-block"><span class="nv">$ </span>readelf <span class="nb">test</span> -d

Dynamic section at offset 0xe18 contains 25 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 <span class="o">(</span>NEEDED<span class="o">)</span>             Shared library: <span class="o">[</span>libtest.so<span class="o">]</span>
 0x0000000000000001 <span class="o">(</span>NEEDED<span class="o">)</span>             Shared library: <span class="o">[</span>libc.so.6<span class="o">]</span>
......
</pre>


<p>dynamic symbols中也有一个undefined symbol(add)</p>
<pre class="code literal-block"><span class="nv">$ </span>nm -D <span class="nb">test </span>
<span class="nb">                 </span>U add
0000000000601048 B __bss_start
0000000000601048 D _edata
0000000000601050 B _end
00000000004007b4 T _fini
                 w __gmon_start__
0000000000400578 T _init
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
                 w _Jv_RegisterClasses
                 U __libc_start_main
                 U <span class="nb">printf</span>
</pre>


<p>在执行隐式链接的程序之前要注意设置<code>LD_LIBRARY_PATH</code>环境变量，或者把前面生成的libtest.so复制到系统路径下，否则会找不到动态库。</p>
<pre class="code literal-block"><span class="err">$</span> <span class="p">.</span><span class="o">/</span><span class="n">test</span> 
<span class="p">.</span><span class="o">/</span><span class="n">test</span><span class="o">:</span> <span class="n">error</span> <span class="k">while</span> <span class="n">loading</span> <span class="n">shared</span> <span class="n">libraries</span><span class="o">:</span> <span class="n">libtest</span><span class="p">.</span><span class="n">so</span><span class="o">:</span> <span class="n">cannot</span> <span class="n">open</span> <span class="n">shared</span> <span class="n">object</span> <span class="n">file</span><span class="o">:</span> <span class="n">No</span> <span class="n">such</span> <span class="n">file</span> <span class="n">or</span> <span class="n">directory</span>

<span class="err">$</span> <span class="n">export</span> <span class="n">LD_LIBRARY_PATH</span><span class="o">=</span><span class="p">.</span>

<span class="err">$</span> <span class="p">.</span><span class="o">/</span><span class="n">test</span> 
<span class="mi">3</span>
</pre>


<h4>2. 显式链接(运行时链接)</h4>
<p>编写主程序dyn_main.c</p>
<pre class="code literal-block"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;dlfcn.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">dl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">add</span><span class="p">)(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">dl</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span> <span class="s">"./libtest.so"</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">dl</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"so loading error.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">add</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span><span class="n">dlsym</span><span class="p">(</span><span class="n">dl</span><span class="p">,</span> <span class="s">"add"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">dlerror</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"fun load error.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>使用<code>gcc dyn_main.c -ldl -o dyn_test</code>编译。</p>
<p>这时通过<code>readelf dyn_test -d</code>可以发现，dyn_test不依赖libtest.so：</p>
<pre class="code literal-block"><span class="err">$</span> <span class="n">readelf</span> <span class="n">dyn_test</span> <span class="o">-</span><span class="n">d</span>

<span class="n">Dynamic</span> <span class="n">section</span> <span class="n">at</span> <span class="n">offset</span> <span class="mh">0xe18</span> <span class="n">contains</span> <span class="mi">25</span> <span class="n">entries</span><span class="o">:</span>
  <span class="n">Tag</span>        <span class="n">Type</span>                         <span class="n">Name</span><span class="o">/</span><span class="n">Value</span>
 <span class="mh">0x0000000000000001</span> <span class="p">(</span><span class="n">NEEDED</span><span class="p">)</span>             <span class="n">Shared</span> <span class="n">library</span><span class="o">:</span> <span class="p">[</span><span class="n">libdl</span><span class="p">.</span><span class="n">so</span><span class="mf">.2</span><span class="p">]</span>
 <span class="mh">0x0000000000000001</span> <span class="p">(</span><span class="n">NEEDED</span><span class="p">)</span>             <span class="n">Shared</span> <span class="n">library</span><span class="o">:</span> <span class="p">[</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="mf">.6</span><span class="p">]</span>
<span class="p">......</span>
</pre>


<p>dyn_test的dynamic symbols中也没有add：</p>
<pre class="code literal-block"><span class="err">$</span> <span class="n">nm</span> <span class="o">-</span><span class="n">D</span> <span class="n">dyn_test</span> 
                 <span class="n">U</span> <span class="n">dlerror</span>
                 <span class="n">U</span> <span class="n">dlopen</span>
                 <span class="n">U</span> <span class="n">dlsym</span>
                 <span class="n">w</span> <span class="n">__gmon_start__</span>
                 <span class="n">w</span> <span class="n">_ITM_deregisterTMCloneTable</span>
                 <span class="n">w</span> <span class="n">_ITM_registerTMCloneTable</span>
                 <span class="n">w</span> <span class="n">_Jv_RegisterClasses</span>
                 <span class="n">U</span> <span class="n">__libc_start_main</span>
                 <span class="n">U</span> <span class="n">printf</span>
                 <span class="n">U</span> <span class="n">puts</span>
</pre>


<p>运行程序也不需要设置<code>LD_LIBRARY_PATH</code>环境变量</p>
<pre class="code literal-block"><span class="nv">$ </span>./dyn_test 
3
</pre>


<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://hi.baidu.com/linuxlife/item/ed8e5d0c6e86b491a2df4366">Linux动态库的编译与使用 转载</a></li>
<li><a href="http://os.51cto.com/art/201003/186246.htm">详细分析Linux动态库的使用方式</a></li>
<li><a href="http://stackoverflow.com/questions/34732/how-do-i-list-the-symbols-in-a-so-file">How do I list the symbols in a .so file</a></li>
<li><a href="http://stackoverflow.com/questions/10480657/import-names-in-elf-binary">Import names in ELF binary</a></li>
</ol>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/cyu-yan-hong-de-te-shu-yong-fa-he-ji-ge-keng.html">C语言宏的特殊用法和几个坑</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2013-07-13T14:25:31+08:00">2013-07-13 14:25</time>
                </div>
                <div class="stats">
                    
        
    <a href="posts/cyu-yan-hong-de-te-shu-yong-fa-he-ji-ge-keng.html#disqus_thread" data-disqus-identifier="cache/posts/cyu-yan-hong-de-te-shu-yong-fa-he-ji-ge-keng.html">Comments</a>


                </div>
            
        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/c.html" rel="tag">C</a></li>
           <li><a class="tag p-category" href="categories/macro.html" rel="tag">Macro</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<p>总结一下C语言中宏的一些特殊用法和几个容易踩的坑。由于本文主要参考GCC文档，某些细节（如宏参数中的空格是否处理之类）在别的编译器可能有细微差别，请参考相应文档。</p>
<h3>宏基础</h3>
<p>宏仅仅是在C预处理阶段的一种文本替换工具，编译完之后对二进制代码不可见。基本用法如下：</p>
<h4>1. 标示符别名</h4>
<pre class="code literal-block"><span class="cp">#define BUFFER_SIZE 1024</span>
</pre>


<p>预处理阶段，<code>foo = (char *) malloc (BUFFER_SIZE);</code>会被替换成<code>foo = (char *) malloc (1024);</code></p>
<p>宏体换行需要在行末加反斜杠\</p>
<pre class="code literal-block"><span class="cp">#define NUMBERS 1, \</span>
<span class="cp">                2, \</span>
<span class="cp">                3</span>
</pre>


<p>预处理阶段<code>int x[] = { NUMBERS };</code>会被扩展成<code>int x[] = { 1, 2, 3 };</code></p>
<h4>2. 宏函数</h4>
<p>宏名之后带括号的宏被认为是宏函数。用法和普通函数一样，只不过在预处理阶段，宏函数会被展开。优点是没有普通函数保存寄存器和参数传递的开销，展开后的代码有利于CPU cache的利用和指令预测，速度快。缺点是可执行代码体积大。</p>
<pre class="code literal-block"><span class="cp">#define min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))</span>
</pre>


<p><code>y = min(1, 2);</code>会被扩展成<code>y = ((1) &lt; (2) ? (1) : (2));</code></p>
<hr>
<h3>宏特殊用法</h3>
<h4>1. 字符串化(Stringification)</h4>
<p>在宏体中，如果宏参数前加个<code>#</code>，那么在宏体扩展的时候，宏参数会被扩展成字符串的形式。如：</p>
<pre class="code literal-block"><span class="cp">#define WARN_IF(EXP) \</span>
<span class="cp">     do { if (EXP) \</span>
<span class="cp">             fprintf (stderr, "Warning: " #EXP "\n"); } \</span>
<span class="cp">     while (0)</span>
</pre>


<p><code>WARN_IF (x == 0);</code>会被扩展成：</p>
<pre class="code literal-block"><span class="k">do</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Warning: "</span> <span class="s">"x == 0"</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre>


<p>这种用法可以用在assert中，如果断言失败，可以将失败的语句输出到反馈信息中</p>
<h4>2. 连接(Concatenation)</h4>
<p>在宏体中，如果宏体所在标示符中有<code>##</code>，那么在宏体扩展的时候，宏参数会被直接替换到标示符中。如：</p>
<pre class="code literal-block"><span class="cp">#define COMMAND(NAME)  { #NAME, NAME ## _command }</span>

<span class="k">struct</span> <span class="n">command</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>
</pre>


<p>在宏扩展的时候</p>
<pre class="code literal-block"><span class="k">struct</span> <span class="n">command</span> <span class="n">commands</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">COMMAND</span> <span class="p">(</span><span class="n">quit</span><span class="p">),</span>
    <span class="n">COMMAND</span> <span class="p">(</span><span class="n">help</span><span class="p">),</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre>


<p>会被扩展成：</p>
<pre class="code literal-block"><span class="k">struct</span> <span class="n">command</span> <span class="n">commands</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span> <span class="s">"quit"</span><span class="p">,</span> <span class="n">quit_command</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"help"</span><span class="p">,</span> <span class="n">help_command</span> <span class="p">},</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre>


<p>这样就节省了大量时间，提高效率。</p>
<hr>
<h3>几个坑</h3>
<h4>1. 语法问题</h4>
<p>由于是纯文本替换，C预处理器不对宏体做任何语法检查，像缺个括号、少个分号神马的预处理器是不管的。这里要格外小心，由此可能引出各种奇葩的问题，一下还很难找到根源。</p>
<h4>2. 算符优先级问题</h4>
<p>不仅宏体是纯文本替换，宏参数也是纯文本替换。有以下一段简单的宏，实现乘法：</p>
<pre class="code literal-block"><span class="cp">#define MULTIPLY(x, y) x * y</span>
</pre>


<p><code>MULTIPLY(1, 2)</code>没问题，会正常展开成<code>1 * 2</code>。有问题的是这种表达式<code>MULTIPLY(1+2, 3)</code>，展开后成了<code>1+2 * 3</code>，显然优先级错了。</p>
<p>在宏体中，给引用的参数加个括号就能避免这问题。</p>
<pre class="code literal-block"><span class="cp">#define MULTIPLY(x, y) (x) * (y)</span>
</pre>


<p><code>MULTIPLY(1+2, 3)</code>就会被展开成<code>(1+2) * (3)</code>，优先级正常了。</p>
<p>其实这个问题和下面要说到的某些问题都属于由于纯文本替换而导致的语义破坏问题，要格外小心。</p>
<h4>3. 分号吞噬问题</h4>
<p>有如下宏定义：</p>
<pre class="code literal-block"><span class="cp">#define SKIP_SPACES(p, limit)  \</span>
<span class="cp">     { char *lim = (limit);         \</span>
<span class="cp">       while (p &lt; lim) {            \</span>
<span class="cp">         if (*p++ != ' ') {         \</span>
<span class="cp">           p--; break; }}}</span>
</pre>


<p>假设有如下一段代码：</p>
<pre class="code literal-block"><span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
   <span class="n">SKIP_SPACES</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lim</span><span class="p">);</span>
<span class="k">else</span> <span class="p">...</span>
</pre>


<p>一编译，GCC报<code>error: ‘else’ without a previous ‘if’</code>。原来这个看似是一个函数的宏被展开后是一段大括号括起来的代码块，加上分号之后这个if逻辑块就结束了，所以编译器发现这个else没有对应的if。</p>
<p>这个问题一般用<code>do ... while(0)</code>的形式来解决：</p>
<pre class="code literal-block"><span class="cp">#define SKIP_SPACES(p, limit)     \</span>
<span class="cp">     do { char *lim = (limit);         \</span>
<span class="cp">          while (p &lt; lim) {            \</span>
<span class="cp">            if (*p++ != ' ') {         \</span>
<span class="cp">              p--; break; }}}          \</span>
<span class="cp">     while (0)</span>
</pre>


<p>展开后就成了</p>
<pre class="code literal-block"><span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">do</span> <span class="p">...</span> <span class="k">while</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">else</span> <span class="p">...</span>
</pre>


<p>这样就消除了分号吞噬问题。</p>
<p>这个技巧在Linux内核源码里很常见，比如这个置位宏<code>#define SET_REG_BIT(reg, bit)              do { (reg |= (1 &lt;&lt; (bit))); } while (0)</code>(位于arch/mips/include/asm/mach-pnx833x/gpio.h)</p>
<h4>4. 宏参数重复调用</h4>
<p>有如下宏定义：</p>
<pre class="code literal-block"><span class="cp">#define min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))</span>
</pre>


<p>当有如下调用时<code>next = min (x + y, foo (z));</code>，宏体被展开成<code>next = ((x + y) &lt; (foo (z)) ? (x + y) : (foo (z)));</code>，可以看到，<code>foo(z)</code>被重复调用了两次，做了重复计算。更严重的是，如果foo是不可重入的(foo内修改了全局或静态变量)，程序会产生逻辑错误。</p>
<p>所以，尽量不要在宏参数中传入函数调用。</p>
<h4>5. 对自身的递归引用</h4>
<p>有如下宏定义：</p>
<pre class="code literal-block"><span class="cp">#define foo (4 + foo)</span>
</pre>


<p>按前面的理解，<code>(4 + foo)</code>会展开成<code>(4 + (4 + foo)</code>，然后一直展开下去，直至内存耗尽。但是，预处理器采取的策略是<strong><em>只展开一次</em></strong>。也就是说，<code>foo</code>只会展开成<code>(4 + foo)</code>，而展开之后<code>foo</code>的含义就要根据上下文来确定了。</p>
<p>对于以下的交叉引用，宏体也只会展开一次。</p>
<pre class="code literal-block"><span class="cp">#define x (4 + y)</span>
<span class="cp">#define y (2 * x)</span>
</pre>


<p><code>x</code>展开成<code>(4 + y) -&gt; (4 + (2 * x))</code>，<code>y</code>展开成<code>(2 * x) -&gt; (2 * (4 + y))</code>。</p>
<p><strong>注意，这是极不推荐的写法，程序可读性极差。</strong></p>
<h4>6. 宏参数预处理</h4>
<p>宏参数中若包含另外的宏，那么宏参数在被代入到宏体之前会做一次完全的展开，除非宏体中含有<code>#</code>或<code>##</code>。</p>
<p>有如下宏定义：</p>
<pre class="code literal-block"><span class="cp">#define AFTERX(x) X_ ## x</span>
<span class="cp">#define XAFTERX(x) AFTERX(x)</span>
<span class="cp">#define TABLESIZE 1024</span>
<span class="cp">#define BUFSIZE TABLESIZE</span>
</pre>


<ul>
<li>
<code>AFTERX(BUFSIZE)</code>会被展开成<code>X_BUFSIZE</code>。因为宏体中含有<code>##</code>，宏参数直接代入宏体。</li>
<li>
<code>XAFTERX(BUFSIZE)</code>会被展开成<code>X_1024</code>。因为<code>XAFTERX(x)</code>的宏体是<code>AFTERX(x)</code>，并没有<code>#</code>或<code>##</code>，所以<code>BUFSIZE</code>在代入前会被完全展开成<code>1024</code>，然后才代入宏体，变成<code>X_1024</code>。</li>
</ul>
<p>-EOF-</p>
<hr>
<p>参考资料：</p>
<p><a href="http://gcc.gnu.org/onlinedocs/cpp/Macros.html">http://gcc.gnu.org/onlinedocs/cpp/Macros.html</a></p>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/python-descriptor.html">Python descriptor</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2013-06-12T12:31:54+08:00">2013-06-12 12:31</time>
                </div>
                <div class="stats">
                    
        
    <a href="posts/python-descriptor.html#disqus_thread" data-disqus-identifier="cache/posts/python-descriptor.html">Comments</a>


                </div>
            
        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/python.html" rel="tag">Python</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<p>一次偶然发现，Python的对象竟然可以在运行期动态添加类定义时没有的属性，这又颠覆了我对Python OO机制的理解。Google了一把，顺着<code>__dict__</code>属性一路找到descriptor，揭开了隐藏在Python对象之后的内幕。</p>
<p>本文主要记录Python的descriptor机制，以及其在Python对象的属性、方法绑定上的作用。</p>
<p>先从本文的始作俑者，运行期动态添加对象属性开始讲起。</p>
<pre class="code literal-block"><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s">'value'</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'function f'</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>
</pre>


<p>以上代码奇迹般的没有报错，而且还输出了1。这肯定会让写过C++/Java代码的童鞋表示吃惊，Python变量类型动态也就不稀奇了，对象属性还能动态添加的？Python到底在背后做了什么？</p>
<h3>神奇的__dict__</h3>
<p>在<code>a.attr = 1</code>前后分别加上一行<code>print(a.__dict__)</code>就会得到如下结果:  </p>
<pre class="code literal-block"><span class="p">{</span><span class="s">'value'</span><span class="p">:</span> <span class="s">'value'</span><span class="p">}</span>  
<span class="mi">1</span>  
<span class="p">{</span><span class="s">'value'</span><span class="p">:</span> <span class="s">'value'</span><span class="p">,</span> <span class="s">'attr'</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span> 
</pre>


<p>显而易见，我们在运行期定义的属性和类定义时定义的属性都被放在了<code>__dict__</code>里。</p>
<p>到这里有人可能就有疑问了，Python里的一切不都是对象麽？为什么成员函数<code>__init__</code>、<code>f</code>不在这个字典里？</p>
<p>看看<code>A.__dict__</code>里有什么就明白了：  </p>
<pre class="code literal-block"><span class="p">{</span><span class="s">'__dict__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">attribute</span> <span class="s">'__dict__'</span> <span class="n">of</span> <span class="s">'A'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="s">'__doc__'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
 <span class="s">'__init__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">__main__</span><span class="o">.</span><span class="n">__init__</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="s">'__module__'</span><span class="p">:</span> <span class="s">'__main__'</span><span class="p">,</span>
 <span class="s">'__weakref__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">attribute</span> <span class="s">'__weakref__'</span> <span class="n">of</span> <span class="s">'A'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="s">'f'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">__main__</span><span class="o">.</span><span class="n">f</span><span class="o">&gt;</span><span class="p">}</span>
</pre>


<p>这时才恍然大悟，如果成员变量看做是对象的属性，那么成员函数就应该看成是类的属性，被全部对象共享嘛。</p>
<p>更精确地讲，以<code>object.attribute</code>访问一个对象的属性时，属性的搜索顺序为：</p>
<ol>
<li>对象自身，<code>object.__dict__</code>
</li>
<li>对象类型，<code>object.__class__.__dict__</code>
</li>
<li>对象类型的基类，<code>object.__class__.__bases__</code>中的所有<code>__dict__</code>。注意，当多重继承的情况下有菱形继承的时候，Python会根据MRO确定的顺序进行搜索。关于MRO(Method Resolution Order)是什么有时间专门写一篇文章总结一下。</li>
</ol>
<p>当以上三个步骤都没有找到要访问的属性的时候Python就只能抛出<code>AttributeError</code>异常了。</p>
<h3>Descriptor是什么</h3>
<p>讲了这么多，貌似跟descriptor半毛钱关系没有嘛。别急，接着往下看。</p>
<pre class="code literal-block"><span class="k">class</span> <span class="nc">RevealAccess</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initval</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">'var'</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">initval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">'Retrieving'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">'Updating'</span> <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
</pre>


<p>来测试一下这个类</p>
<pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">RevealAccess</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">'var "x"'</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">x</span>
<span class="n">Retrieving</span> <span class="n">var</span> <span class="s">"x"</span>
<span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">Updating</span> <span class="n">var</span> <span class="s">"x"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">x</span>
<span class="n">Retrieving</span> <span class="n">var</span> <span class="s">"x"</span>
<span class="mi">20</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">y</span>
<span class="mi">5</span>
</pre>


<p>这个<code>RevealAccess</code>的对象就是一个descriptor，其作用就是在存取变量的时候做了一个hook。访问属性<code>m.x</code>就是调用<code>__get__</code>方法，设置属性值就是调用<code>__set__</code>方法。还可以有一个<code>__delete__</code>方法，在<code>del m.x</code>时被调用。</p>
<p>只要一个类定义了以上三种方法，其对象就是一个descriptor。我们把同时定义<code>__get__</code>和<code>__set__</code>方法的descriptor叫做<strong>data descriptor</strong>，把只定义<code>__get__</code>方法的叫<strong>non-data descriptor</strong></p>
<h3>Method binding</h3>
<p>有了以上两个概念，我们就能讨论Python的方法绑定了。</p>
<p>还记得讨论<code>__dict__</code>时的成员函数<code>f</code>吗？按照我们的推测，<code>A.__dict__['f']</code>应该和<code>a.f</code>是一个东西。但是！！！</p>
<pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">'f'</span><span class="p">]</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">__main__</span><span class="o">.</span><span class="n">f</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">f</span>
<span class="o">&lt;</span><span class="n">bound</span> <span class="n">method</span> <span class="n">A</span><span class="o">.</span><span class="n">f</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">A</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f9d69cc5950</span><span class="o">&gt;&gt;</span>
</pre>


<p>这两个显然不是一个东西，一个是<code>function</code>，一个是<code>bound method</code>。这是什么情况？淡定，看下面</p>
<pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">'f'</span><span class="p">]</span><span class="o">.</span><span class="n">__get__</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">bound</span> <span class="n">method</span> <span class="n">A</span><span class="o">.</span><span class="n">f</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">A</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f9d69cc5950</span><span class="o">&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">f</span>
<span class="o">&lt;</span><span class="n">bound</span> <span class="n">method</span> <span class="n">A</span><span class="o">.</span><span class="n">f</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">A</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f9d69cc5950</span><span class="o">&gt;&gt;</span>
</pre>


<p>这下放心了吧:D</p>
<p>其实，类的成员函数就是一个descriptor，在实例化对象a的时候，Python就做了这么一个过程(伪码，详见Objects/funcobject.c)：<code>a.f = A.__dict__['f'].__get__(a, A)</code></p>
<p>纯Python模拟的函数对象就像这样：</p>
<pre class="code literal-block"><span class="k">class</span> <span class="nc">Function</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="s">"Simulate func_descr_get() in Objects/funcobject.c"</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="p">)</span>
</pre>


<p>然后就好理解<code>staticmethod</code>和<code>classmethod</code>这两个decorator了吧。<code>staticmethod</code>无视了传入的第一个self参数，<code>classmethod</code>手工加了一个类对象参数进去。它们的纯Python模拟就像下面所示：</p>
<pre class="code literal-block"><span class="k">class</span> <span class="nc">StaticMethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
 <span class="s">"Emulate PyStaticMethod_Type() in Objects/funcobject.c"</span>

 <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>

 <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span>

<span class="k">class</span> <span class="nc">ClassMethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
     <span class="s">"Emulate PyClassMethod_Type() in Objects/funcobject.c"</span>

     <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>

     <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">klass</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
               <span class="n">klass</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
          <span class="k">def</span> <span class="nf">newfunc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
               <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">newfunc</span>
</pre>


<hr>
<p>研究Python的底层实现是个很有意思的事，至少能让我在使用Python时更加放心：）</p>
<p>全文完</p>
<hr>
<p>参考资料：</p>
<ol>
<li>How-To Guide for Descriptors: <a href="http://users.rcn.com/python/download/Descriptor.htm">http://users.rcn.com/python/download/Descriptor.htm</a>
</li>
<li>Python Attributes and Methods: <a href="http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html">http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html</a>
</li>
<li>《Expert Python Programming》,Tarek Ziadé: <a href="http://book.douban.com/subject/3285148/">http://book.douban.com/subject/3285148/</a>
</li>
</ol>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/trieshu-de-pythonshi-xian.html">Trie树的Python实现</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2013-05-21T19:48:53+08:00">2013-05-21 19:48</time>
                </div>
                <div class="stats">
                    
        
    <a href="posts/trieshu-de-pythonshi-xian.html#disqus_thread" data-disqus-identifier="cache/posts/trieshu-de-pythonshi-xian.html">Comments</a>


                </div>
            
        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/python.html" rel="tag">Python</a></li>
           <li><a class="tag p-category" href="categories/shu-ju-jie-gou.html" rel="tag">数据结构</a></li>
           <li><a class="tag p-category" href="categories/suan-fa.html" rel="tag">算法</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<p>又是一个由需求驱动的算法学习的例子。</p>
<p>最近<a href="https://github.com/hbprotoss/weibo">weii</a>需要实现一个这样的功能：在发送AT好友的时候能给出自动补全的列表。</p>
<p>最先想到的是当我给出一个用户名的前几个字的时候能自动提示以这个字开头的所有用户名列表（虽然最后发现这是个很2的解决方案-_-），所以最理想的数据结构就是Trie树，也就是字典树。</p>
<p>以前只听过Trie树，现在实际要用了就得把他落到实处了。</p>
<p>首先是<a href="http://zh.wikipedia.org/wiki/Trie">Trie树在维基百科上的定义</a>：在计算机科学中，trie，又称前缀树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>说白了就跟在字典里查单词一样：先拿第一个字母在根节点查找下一结点的位置，如果找到就拿第二个字母在刚刚找到的节点下继续往下查找；如果找不到就说明这个字符串在树中不存在。</p>
<p>C语言实现的代码也在维基百科上：<a href="http://zh.wikipedia.org/wiki/Trie#.E5.AE.9E.E4.BE.8B">http://zh.wikipedia.org/wiki/Trie#.E5.AE.9E.E4.BE.8B</a></p>
<pre class="code literal-block"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="cp">#define TREE_WIDTH 256</span>

<span class="cp">#define WORDLENMAX 128</span>

<span class="k">struct</span> <span class="n">trie_node_st</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">trie_node_st</span> <span class="o">*</span><span class="n">next</span><span class="p">[</span><span class="n">TREE_WIDTH</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">trie_node_st</span> <span class="n">root</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">}};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">spaces</span><span class="o">=</span><span class="s">" </span><span class="se">\t\n</span><span class="s">/.</span><span class="se">\"\'</span><span class="s">()"</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">trie_node_st</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="o">*</span><span class="n">newnode</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">newnode</span><span class="o">=</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie_node_st</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie_node_st</span><span class="p">));</span>
                        <span class="n">memset</span><span class="p">(</span><span class="n">newnode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie_node_st</span><span class="p">));</span>
                        <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="n">newnode</span><span class="p">;</span>
                <span class="p">}</span> 
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">];</span>
        <span class="p">}</span>
        <span class="n">curr</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">++</span><span class="p">;</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">printword</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\t</span><span class="s">%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">do_travel</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie_node_st</span> <span class="o">*</span><span class="n">rootp</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">static</span> <span class="kt">char</span> <span class="n">worddump</span><span class="p">[</span><span class="n">WORDLENMAX</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">rootp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rootp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">worddump</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">=</span><span class="sc">'\0'</span><span class="p">;</span>
                <span class="n">printword</span><span class="p">(</span><span class="n">worddump</span><span class="p">,</span> <span class="n">rootp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">TREE_WIDTH</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">worddump</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
                <span class="n">do_travel</span><span class="p">(</span><span class="n">rootp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="n">pos</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">linebuf</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">line</span><span class="p">,</span> <span class="o">*</span><span class="n">word</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">bufsize</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ret</span><span class="o">=</span><span class="n">getline</span><span class="p">(</span><span class="o">&amp;</span><span class="n">linebuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bufsize</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">line</span><span class="o">=</span><span class="n">linebuf</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">word</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">line</span><span class="p">,</span> <span class="n">spaces</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">word</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                                <span class="k">break</span><span class="p">;</span>
                        <span class="p">}</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
                                <span class="k">continue</span><span class="p">;</span>
                        <span class="p">}</span>
                        <span class="n">insert</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
                <span class="p">}</span>
        <span class="p">}</span>

<span class="cm">/* free(linebuf); */</span>

        <span class="n">do_travel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>

        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre>


<p>但这个版本的实现有两个问题：</p>
<ol>
<li>非常耗内存，一个节点下必须有TREE_WIDTH个子节点，不管子节点代表的字母是否出现在Trie树里。这是非常暴力的哈希。。。</li>
<li>设定了这个TREE_WIDTH也就意味着这个实现只支持ASCII表中的字符作键，不支持中文。</li>
</ol>
<p>Python内置的dict是用哈希实现的，正好可以解决这两个问题。（dict的基本原理可以参考<a href="http://blog.csdn.net/digimon/article/details/7875789">《Python源码剖析》阅读笔记：第五章-dict对象</a>）</p>
<ol>
<li>dict采用的是开放寻址法解决冲突，节省了内存，但时间复杂度还是O(1)。</li>
<li>dict这个哈希表里可以放任意字符作为键，中文当然也不例外。</li>
</ol>
<p>Python版的关键改造就是节点的next表用dict代替，维护的是<code>字符-&gt;子节点</code>的映射。查找时，若待查询字符是next里的一个键就说明该字符在Trie树里，以这个键得到值就能找到下一节点。插入时也只要插入<code>字符-&gt;子节点</code>的映射就可以了。</p>
<p>具体代码在：<a href="https://github.com/hbprotoss/codejam/blob/master/trie.py">https://github.com/hbprotoss/codejam/blob/master/trie.py</a></p>
<pre class="code literal-block"><span class="c">#!/usr/bin/env python3</span>

<span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>
    <span class="n">root</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findLastNode</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">string</span><span class="p">[</span><span class="n">index</span><span class="p">:]:</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">node</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">new_node</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findLastNode</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">findLastNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
        <span class="sd">'''</span>
<span class="sd">        @param string: string to be searched</span>
<span class="sd">        @return: (index, node).</span>
<span class="sd">            index: int. first char(string[index]) of string not found in Trie tree. Otherwise, the length of string</span>
<span class="sd">            node: dict. node doesn't have string[index].</span>
<span class="sd">        '''</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
            <span class="n">char</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">printTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span>

        <span class="n">rtns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">rtns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">rtns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">printTree</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">layer</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">rtns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'.'</span> <span class="o">*</span> <span class="n">layer</span><span class="p">)</span>
            <span class="n">rtns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">rtns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">printTree</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">layer</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rtns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">printTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">src</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">src</span> <span class="o">==</span> <span class="s">''</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</pre>


<p>全文完。</p>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/tong-su-yan-yi-kmp.html">通俗演绎KMP</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2013-05-07T20:09:38+08:00">2013-05-07 20:09</time>
                </div>
                <div class="stats">
                    
        
    <a href="posts/tong-su-yan-yi-kmp.html#disqus_thread" data-disqus-identifier="cache/posts/tong-su-yan-yi-kmp.html">Comments</a>


                </div>
            
        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/zi-fu-chuan.html" rel="tag">字符串</a></li>
           <li><a class="tag p-category" href="categories/suan-fa.html" rel="tag">算法</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<p>最近要实现关键字过滤功能，小看了一些经典的字符串匹配算法。<br>
本文要介绍的是KMP算法（<strong>Knuth–Morris–Pratt Algorithm</strong>）,那个Knuth应该再熟悉不过了。  </p>
<p>KMP算法是从朴素匹配算法改进而来。回忆一下朴素的匹配算法是怎么完成字符串的匹配的呢？<br>
1. 将原串和模式串左对齐，然后一位一位比较，直到有一个字符不匹配<br>
<img alt="KMP1.png" src="galleries/KMP/KMP1.png" title=""><br>
2. 发现第二位的B和C不匹配，模式串右移一位<br>
<img alt="KMP2.png" src="galleries/KMP/KMP2.png" title=""><br>
3. 重复这个流程，直到找到完全匹配的子串或者匹配失败。</p>
<p>但这过程中显然有多比较的地方。如，原串为ABCDEABCDF，模式串为ABCDF。第一轮可以发现E和F不匹配<br>
<img alt="KMP3.png" src="galleries/KMP/KMP3.png" title=""><br>
很显然右移一位必定不匹配，这时模式串可以直接右移4位跳过ABCD，从E开始再次比较<br>
<img alt="KMP4.png" src="galleries/KMP/KMP4.png" title="">  </p>
<p>那是不是跳过的长度就是前面相同部分的长度呢？其实不是这样的，这种直接跳过前面相同部分的做法在某些情况下会有问题。如，原串为ABCDABCDABF，模式串为ABCDABF，直接跳过相同部分就会遗漏匹配的串<br>
<img alt="KMP5.png" src="galleries/KMP/KMP5.png" title=""><br>
所以跳过的长度并不是前面完全匹配的部分，可以跳过的长度一般存储在模式串的partial match table中，即KMP算法需要对模式串进行预处理。</p>
<p>先来看看这个partial match table在跳过的过程中是怎么用的，然后再来考察计算partial match table的算法。<br>
ABCDABF的partial match table如下：<br>
<img alt="KMP6.png" src="galleries/KMP/KMP6.png" title=""><br>
可以跳过的长度 = 当前已匹配长度 - 最后一个字母在partial match table中的值。例如：<br>
<img alt="KMP7.png" src="galleries/KMP/KMP7.png" title=""><br>
当发现C和F不匹配时，根据公式，当前已匹配串ABCDAB长度为6, 最后一个字母B在partial match table中的对应值为2，所以可以跳过的长度 = 6 - 2 = 4，即：<br>
<img alt="KMP8.png" src="galleries/KMP/KMP8.png" title=""><br>
这样就能正确匹配了。</p>
<p>partial match table中每个位置i记录的其实就是从0到i的子串中，同时出现在子串前缀和后缀中的最大长度。还是以上面那个例子为例：  </p>
<ul>
<li>A没有前缀或后缀，所以长度为0</li>
<li>AB前缀为A，后缀为B，没有相同部分，长度为0</li>
<li>ABC前缀为A、AB，后缀为BC、C，没有相同部分，长度为0</li>
<li>ABCD前缀为A、AB、ABC，后缀为BCD、CD、D，没有相同部分，长度为0</li>
<li>ABCDA前缀为A、AB、ABC、ABCD，后缀为BCDA、CDA、DA、A，相同部分为A，长度为1</li>
<li>ABCDAB前缀为A、AB、ABC、ABCD、ABCDA，后缀为BCDAB、CDAB、DAB、AB、B，相同部分为AB，长度为2</li>
<li>ABCDABF前缀为A、AB、ABC、ABCD、ABCDA、ABCDAB，后缀为BCDABF、BCDAB、CDAB、DAB、AB、B，没有相同部分，长度为0</li>
</ul>
<p>具体代码参考<a href="https://github.com/hbprotoss/codejam/blob/master/kmp.py">https://github.com/hbprotoss/codejam/blob/master/kmp.py</a></p>
<p>全文完。</p>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/python-decoratorde-ying-yong.html">Python decorator的应用</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2013-04-03T21:23:39+08:00">2013-04-03 21:23</time>
                </div>
                <div class="stats">
                    
        
    <a href="posts/python-decoratorde-ying-yong.html#disqus_thread" data-disqus-identifier="cache/posts/python-decoratorde-ying-yong.html">Comments</a>


                </div>
            
        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/design-pattern.html" rel="tag">Design Pattern</a></li>
           <li><a class="tag p-category" href="categories/python.html" rel="tag">Python</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<p>Decorator是23种设计模式之一，提出的目的是为了在不改变现有代码的前提下，通过在头部或尾部添加代码来扩展功能。<br>
Python语言内建支持decorator模式。由于语法不是本文重点，对语法不熟悉的童鞋可以参考以下几篇文章：  </p>
<ol>
<li>Stackoverflow上的神文：<a href="http://stackoverflow.com/a/1594484/837187">Understanding Python decorators</a>
</li>
<li><a href="http://blog.donews.com/limodou/archive/2004/12/19/207521.aspx">[Python学习]decorator的使用</a></li>
<li><a href="http://www.python.org/dev/peps/pep-0318/">PEP318</a></li>
</ol>
<p>下面说一下最近在写SNS客户端插件时Python decorator的应用。<br>
插件的方法完成的任务是：  </p>
<ul>
<li>根据OAuth协议，设置好参数，访问HTTP API</li>
<li>读取服务器返回的json</li>
<li>解析json</li>
</ul>
<p>异常可能来自访问API过程中的网络问题，以及解析json发现服务器返回了错误代码（比如API访问过于频繁，access token有问题等）。在写头几个API的时候做法很自然，用try-except块包裹可能出异常的代码，将各种标准库的异常或者服务器返回的错误信息封装成自己的exception，raise一下告诉主程序有异常需要处理。<br>
但是写了几个方法后发现，每个方法的异常处理流程几乎一模一样，特别是封装标准库的异常，唯一不同的就是解析服务器返回的错误信息。伪码如下：  </p>
<pre class="code literal-block"><span class="n">def</span> <span class="n">method</span><span class="p">(</span><span class="n">xxx</span><span class="p">)</span><span class="o">:</span>
    <span class="nl">try:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">urllib</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span>
        <span class="n">raw_data</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">decode</span><span class="p">(</span><span class="err">'</span><span class="n">utf</span><span class="o">-</span><span class="mi">8</span><span class="err">'</span><span class="p">)</span>
        <span class="n">rtn</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="n">loads</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>
    <span class="n">except</span> <span class="n">Exception1</span> <span class="n">as</span> <span class="n">e</span><span class="o">:</span>
        <span class="n">log</span><span class="p">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">raise</span> <span class="n">CustomException1</span><span class="p">()</span>
    <span class="n">except</span> <span class="n">Exception2</span> <span class="n">as</span> <span class="n">e</span><span class="o">:</span>
        <span class="n">log</span><span class="p">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">raise</span> <span class="n">CustomException2</span><span class="p">()</span>
        <span class="n">xxx</span>
    <span class="nl">else:</span>
        <span class="k">return</span> <span class="n">rtn</span>
</pre>


<p>出于懒的原因（说得好听点，出于代码复用的目的:D)，得想个办法把这些重复性的工作提取出来。<br>
仔细观察可以发现，这些方法在except处理完异常之后都没有额外的工作需要进行。换句话说，可以认为这些代码都位于核心处理代码之后，这是自然就想到了decorator模式，将异常处理放在decorator里，再decorate一下各个方法就可以了。<br>
Decorator如下：  </p>
<pre class="code literal-block"><span class="n">def</span> <span class="n">sinaMethod</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">:</span>
    <span class="n">def</span> <span class="n">func_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">:</span>
        <span class="nl">try:</span>
            <span class="n">raw_rtn</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">except</span> <span class="n">urllib</span><span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="n">HTTPError</span> <span class="n">as</span> <span class="n">e</span><span class="o">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="p">.</span><span class="n">fp</span><span class="o">:</span>
                <span class="err">#</span> <span class="n">Sina</span> <span class="n">app</span> <span class="n">error</span>
                <span class="n">error_msg</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="n">loads</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">fp</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">decode</span><span class="p">(</span><span class="err">'</span><span class="n">utf</span><span class="o">-</span><span class="mi">8</span><span class="err">'</span><span class="p">))</span>
                <span class="n">error_code</span> <span class="o">=</span> <span class="n">str</span><span class="p">(</span><span class="n">error_msg</span><span class="p">[</span><span class="err">'</span><span class="n">error_code</span><span class="err">'</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">error_code</span> <span class="n">in</span> <span class="n">exception_dict</span><span class="o">:</span>
                    <span class="n">raise</span> <span class="n">exception_dict</span><span class="p">[</span><span class="n">error_code</span><span class="p">](</span><span class="n">error_msg</span><span class="p">[</span><span class="err">'</span><span class="n">error</span><span class="err">'</span><span class="p">])</span>
                <span class="nl">else:</span>
                    <span class="n">raise</span> <span class="n">weiUnknownError</span><span class="p">(</span><span class="n">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="nl">else:</span>
                <span class="err">#</span> <span class="n">Network</span> <span class="n">error</span>
                <span class="n">raise</span> <span class="n">weiNetworkError</span><span class="p">(</span><span class="n">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="nl">else:</span>
            <span class="k">return</span> <span class="n">raw_rtn</span>
    <span class="k">return</span> <span class="n">func_wrapper</span>
</pre>


<p>其作用就是，尝试调用被装饰函数，如果顺利的话直接返回结果。如果有HTTPError异常发生，则解析之，并根据相应情况封装成自定义的异常抛出。<br>
这里使得代码比较简短的一个关键就是这个exception_dict，里面维护了新浪错误代码和需要抛出的异常类之间的映射。根据返回的error_code查找这个字典，如果有则说明这是我们需要关心的异常，那么就用错误消息构造异常对象抛出。如果没有，就不是需要关心的异常，以weiUnknownError异常抛出。<br>
由于新浪在出错时除了返回HTTP报头，还有一段附加data，所以如果e.fp为None则说明不是应用层的异常，可能是网络层及以下出了问题，抛出weiNetworkError。  </p>
<p>使用就很简单了，在被装饰的函数前一行加<code>@sinaMethod</code>就可以了。<br>
就这么简单~~  </p>
<hr>
<p>PS：附带说一句，编程语言对设计模式在语法上的支持会大大简化程序猿的编码量。如果是C++/Java，甚至C要用decorator模式就得协商老长一段了~~^_^</p>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/multipartform-datade-shi-xian.html">multipart/form-data的实现</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2013-03-29T09:19:39+08:00">2013-03-29 09:19</time>
                </div>
                <div class="stats">
                    
        
    <a href="posts/multipartform-datade-shi-xian.html#disqus_thread" data-disqus-identifier="cache/posts/multipartform-datade-shi-xian.html">Comments</a>


                </div>
            
        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/python.html" rel="tag">Python</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<p>写之前先吐槽几句：Python社区太懒了，Python3都推出多少年了，那么多第三方库还不port到Python3。不能安于现状啊！  </p>
<hr>
<p>下面是正题：</p>
<p>最近写微博客户端，上传图片需要multipart/form-data编码图片和参数，由于前面说的原因，没有第三方库可用，所以就自己实现一下。</p>
<p>先贴一下multipart/form-data的RFC文档地址：<a href="http://www.ietf.org/rfc/rfc2388.txt">点这里</a></p>
<p>multipart/form-data主要由三部分组成：  </p>
<ol>
<li>HTTP Header。需要添加头"Content-Type: multipart/form-data; boundary=%s"，这个boundary就是分隔符，见第二条。</li>
<li>分隔符boundary。分隔符是一串和正文内容不冲突的字符串，用以分割多个参数。一般都是N个减号+随机字符串，比如"----------当前时间"。<br>
   正文需要加header：<br>
   Content-Disposition: form-data; name="%s"，%s为需要传递的变量名。<br>
   Content-Type: 指定正文MIME类型，默认是纯文本text/plain，未知类型可以填application/octet-stream。  </li>
<li>数据。要注意的是数据的编码，文档上说"7BIT encoding"，ISO-8859-1即可。</li>
</ol>
<p>下面贴一段上传新浪微博图片的代码：  </p>
<table class="codehilitetable"><tr>
<td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></div></td>
<td class="code">
<pre class="code literal-block"><span class="c">#!/usr/bin/env python3</span>

<span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="kn">import</span> <span class="nn">urllib.error</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">mimetypes</span>

<span class="k">def</span> <span class="nf">_encode_multipart</span><span class="p">(</span><span class="n">params_dict</span><span class="p">):</span>
    <span class="sd">'''</span>
<span class="sd">    Build a multipart/form-data body with generated random boundary.</span>
<span class="sd">    '''</span>
    <span class="n">boundary</span> <span class="o">=</span> <span class="s">'----------%s'</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">params_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'--%s'</span> <span class="o">%</span> <span class="n">boundary</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s">'read'</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s">'name'</span><span class="p">,</span> <span class="s">''</span><span class="p">)</span>
        <span class="n">content</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">decoded_content</span> <span class="o">=</span> <span class="n">content</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">'ISO-8859-1'</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'Content-Disposition: form-data; name="%s"; filename="hidden"'</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'Content-Type: application/octet-stream</span><span class="se">\r\n</span><span class="s">'</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decoded_content</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'Content-Disposition: form-data; name="%s"</span><span class="se">\r\n</span><span class="s">'</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">))</span>
    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'--%s--</span><span class="se">\r\n</span><span class="s">'</span> <span class="o">%</span> <span class="n">boundary</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">'</span><span class="se">\r\n</span><span class="s">'</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">boundary</span>

<span class="c">#############################################################</span>
<span class="n">url</span> <span class="o">=</span> <span class="s">'https://upload.api.weibo.com/2/statuses/upload.json'</span>
<span class="n">access_token</span> <span class="o">=</span> <span class="s">'xxx'</span>
<span class="n">file_name</span> <span class="o">=</span> <span class="s">'big.png'</span>
<span class="n">path</span> <span class="o">=</span> <span class="s">'/home/xxx/Downloads/'</span> <span class="o">+</span> <span class="n">file_name</span>
<span class="n">status</span> <span class="o">=</span> <span class="s">'1234567'</span>

<span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'access_token'</span><span class="p">:</span> <span class="n">access_token</span><span class="p">,</span>
    <span class="s">'status'</span><span class="p">:</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">quote</span><span class="p">(</span><span class="n">status</span><span class="p">),</span>
    <span class="s">'pic'</span><span class="p">:</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">coded_params</span><span class="p">,</span> <span class="n">boundary</span> <span class="o">=</span> <span class="n">_encode_multipart</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

<span class="c">#############################################################</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">coded_params</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">'ISO-8859-1'</span><span class="p">))</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s">'Content-Type'</span><span class="p">,</span> <span class="s">'multipart/form-data; boundary=%s'</span> <span class="o">%</span> <span class="n">boundary</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
    <span class="n">body</span> <span class="o">=</span> <span class="n">resp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
<span class="k">except</span> <span class="n">urllib</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">HTTPError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</pre>
</td>
</tr></table>

<p><strong>其中尤其要注意的是，POST上去的data部分要encode成ISO-8859-1。一开始一直encode成UTF-8，死活报的都是格式错误。</strong></p>
</div>
            </div>
        </div>
    
        <nav class="postindexpager">
        <ul class="pager">
            <li class="next">
                <a href="index-1.html" rel="next">Older posts</a>
            </li>
        </ul>
        </nav>

    
        
       <script>var disqus_shortname="hbprotoss";(function(){var a=document.createElement("script");a.async=true;a.src="//"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>


    


             
        <footer id="footer" role="contentinfo">
            <p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png"></a><br>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。
<br>Contents © 2014 <a href="mailto:">hbprotoss</a> - Powered by <a href="http://nikola.ralsina.com.ar">Nikola</a></p>
            
        </footer>

        </div>
    </section>
    
    
    
            <script src="assets/js/all-nocdn.js" type="text/javascript"></script>
    
<!-- Social buttons -->
<div id="addthisbox" class="addthis_toolbox addthis_peekaboo_style addthis_default_style addthis_label_style addthis_32x32_style">
<a class="addthis_button_more">Share</a>
<ul>
<li>
<a class="addthis_button_facebook"></a>
</li>
<li>
<a class="addthis_button_google_plusone_share"></a>
</li>
<li>
<a class="addthis_button_linkedin"></a>
</li>
<li>
<a class="addthis_button_twitter"></a>
</li>
</ul>
</div>
<script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4f7088a56bb93798"></script>
<!-- End of social buttons -->


    
        <script type="text/javascript">
            $(function(){
                $('.timeago').timeago();
            });
        </script>
    
</body>
</html>
