<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>hbprotoss的博客 | hbprotoss的博客</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="http://hbprotoss.github.io/index.html">
<link rel="next" href="index-1.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]--><link rel="prefetch" href="posts/thymeleafde-keng-yi-ji.html" type="text/html">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<div class="blog-masthead">
    <div class="container">
<!-- This keeps the margins nice -->
        <nav class="blog-nav" role="navigation"><a href="#" class="blog-nav-item active">Home <span class="sr-only">(active)</span></a>
            <a href="archive.html" class="blog-nav-item">Archives</a>
            <a href="categories/index.html" class="blog-nav-item">Tags</a>
            <a href="rss.xml" class="blog-nav-item">RSS</a>

            

                
                
                    
                
            
        </nav>
</div>
<!-- /.container -->
</div>
<!-- End of Menubar -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <div class="blog-header">
            <h1 class="blog-title">
                <a href="http://hbprotoss.github.io/">

                    <span id="blog-title">hbprotoss的博客</span>
                </a>
            </h1>
            <p class="lead blog-description"></p>
            
        </div>
        <!--Body content-->
        <div class="row">
            <div class="col-sm-8 blog-main">
                

<div class="postindex">
    <article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/thymeleafde-keng-yi-ji.html" class="u-url">thymeleaf的坑一记</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/thymeleafde-keng-yi-ji.html" rel="bookmark"><time class="published dt-published" datetime="2016-05-31T08:37:04+08:00" title="2016-05-31 08:37">2016-05-31 08:37</time></a></p>
                <p class="commentline">
        
    <a href="posts/thymeleafde-keng-yi-ji.html#disqus_thread" data-disqus-identifier="cache/posts/thymeleafde-keng-yi-ji.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>记录下thymeleaf 3.0新增的<code>th:field</code>与<code>th:each</code>中生成的变量结合使用时的坑。</p>
<p>代码就是官方例子<a href="https://github.com/thymeleaf/thymeleafexamples-stsm.git">https://github.com/thymeleaf/thymeleafexamples-stsm.git</a>，在<code>webapp/WEB-INF/seedstartermng.html</code>中118-131行</p>
<pre class="code literal-block"><span></span><span class="p">&lt;</span><span class="nt">tr</span> <span class="na">th:each</span><span class="o">=</span><span class="s">"row,rowStat : *{rows}"</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span> <span class="na">th:text</span><span class="o">=</span><span class="s">"${rowStat.count}"</span><span class="p">&gt;</span>1<span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">select</span> <span class="na">th:field</span><span class="o">=</span><span class="s">"*{rows[__${rowStat.index}__].variety}"</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">option</span> <span class="na">th:each</span><span class="o">=</span><span class="s">"var : ${allVarieties}"</span> <span class="na">th:value</span><span class="o">=</span><span class="s">"${var.id}"</span> <span class="na">th:text</span><span class="o">=</span><span class="s">"${var.name}"</span><span class="p">&gt;</span>Thymus Thymi<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">select</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">th:field</span><span class="o">=</span><span class="s">"*{rows[__${rowStat.index}__].seedsPerCell}"</span> <span class="na">th:errorclass</span><span class="o">=</span><span class="s">"fieldError"</span> <span class="p">/&gt;</span>
  <span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">button</span> <span class="na">type</span><span class="o">=</span><span class="s">"submit"</span> <span class="na">name</span><span class="o">=</span><span class="s">"removeRow"</span> <span class="na">th:value</span><span class="o">=</span><span class="s">"${rowStat.index}"</span> <span class="na">th:text</span><span class="o">=</span><span class="s">"#{seedstarter.row.remove}"</span><span class="p">&gt;</span>Remove row<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">tr</span><span class="p">&gt;</span>
</pre>


<p>其中第二个td取出rows中的每一行的variety，做成一个select下拉菜单，当我尝试用<code>${row.variety}</code>替换原文的<code>*{rows[__${rowStat.index}__].variety}</code>时，页面渲染抛出异常<code>Neither BindingResult nor plain target object for bean name 'row' available as request attribute</code>。多方探索之后得出结论：这是我们使用的问题，设计时特意在遇到这种情况时为了避免服务端无法处理提交后的表单，就抛出异常。</p>
<p>用例子中的代码渲染完生成后的页面为：</p>
<pre class="code literal-block"><span></span><span class="p">&lt;</span><span class="nt">tr</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>1<span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">select</span> <span class="na">id</span><span class="o">=</span><span class="s">"rows0.variety"</span> <span class="na">name</span><span class="o">=</span><span class="s">"rows[0].variety"</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">"1"</span><span class="p">&gt;</span>Thymus vulgaris<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">"2"</span><span class="p">&gt;</span>Thymus x citriodorus<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">"3"</span><span class="p">&gt;</span>Thymus herba-barona<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">"4"</span><span class="p">&gt;</span>Thymus pseudolaginosus<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">"5"</span><span class="p">&gt;</span>Thymus serpyllum<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">select</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">id</span><span class="o">=</span><span class="s">"rows0.seedsPerCell"</span> <span class="na">name</span><span class="o">=</span><span class="s">"rows[0].seedsPerCell"</span> <span class="na">value</span><span class="o">=</span><span class="s">""</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">button</span> <span class="na">type</span><span class="o">=</span><span class="s">"submit"</span> <span class="na">name</span><span class="o">=</span><span class="s">"removeRow"</span> <span class="na">value</span><span class="o">=</span><span class="s">"0"</span><span class="p">&gt;</span>Remove row<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">tr</span><span class="p">&gt;</span>
</pre>


<p>其中，<code>th:field</code>在渲染时会给目标元素加上id和name属性，name属性取<code>*{...}</code>中表达式的值。由于<code>__${rowStat.index}__</code>是个预处理语句，在渲染之前会直接文本替换，所以最终的表达式为<code>rows[0].variety</code>。</p>
<p>但是如果是<code>${row.variety}</code>，则最终name会被替换为<code>row.variety</code>，由于浏览器作为客户端无法知道服务端的逻辑，这样之后的每个tr中的元素都是这个表达式，表单提交的时候无法被spring解析成一个list对象，就会出现错误。</p>
<p>官方站在实现角度的解释可以看这个<a href="https://github.com/thymeleaf/thymeleaf/issues/505#issuecomment-222557959">issue</a></p>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/xpathbei-wang.html" class="u-url">XPath备忘</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/xpathbei-wang.html" rel="bookmark"><time class="published dt-published" datetime="2016-04-12T15:46:09+08:00" title="2016-04-12 15:46">2016-04-12 15:46</time></a></p>
                <p class="commentline">
        
    <a href="posts/xpathbei-wang.html#disqus_thread" data-disqus-identifier="cache/posts/xpathbei-wang.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>最近写了几个scrapy的爬虫程序，里面用到了xpath，写个日志记录一下用法。</p>
<h2>XPath是什么</h2>
<p>XPath是一种用于xml、html等结构化文档中寻址定位特定元素等描述性语言</p>
<h2>XPath主要功能</h2>
<p>下面以如下测试文档为例进行说明：</p>
<pre class="code literal-block"><span></span><span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">contents</span> <span class="na">id</span><span class="o">=</span><span class="s">"content"</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">para</span><span class="p">&gt;&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">"one.html"</span> <span class="na">class</span><span class="o">=</span><span class="s">"normal-link"</span><span class="p">&gt;</span>One<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;&lt;/</span><span class="nt">para</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">para</span><span class="p">&gt;&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">"two.html"</span> <span class="na">class</span><span class="o">=</span><span class="s">"normal-link"</span><span class="p">&gt;</span>Two<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;&lt;/</span><span class="nt">para</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">para</span><span class="p">&gt;&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">"three.html"</span> <span class="na">class</span><span class="o">=</span><span class="s">"ex-link"</span><span class="p">&gt;</span>Three<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;&lt;/</span><span class="nt">para</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">contents</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</pre>


<h3>精确路径寻址</h3>
<p>指通过精确制定的路径取得元素。例如</p>
<p>和unix文件系统概念一致，有如下几种定位方式：</p>
<ul>
<li>绝对路径，<code>/html/body/contents/para</code>能查找出文档中的三个para元素</li>
<li>相对路径，在<code>/html/body</code>路径下，<code>/contents/para</code>同样也能查找出这三个para元素</li>
<li>父级路径，<code>.</code>表示当前路径，<code>..</code>表示当前路径的父级路径</li>
</ul>
<h3>模糊路径寻址</h3>
<p>不需要指定绝对路径或根据当前路径确定的相对路径，只需要指定某个子结构，就能查找出所有符合这个子结构的元素。如</p>
<ul>
<li>
<code>//contents/para</code>在任何路径下，都能查找到<strong>整个文档</strong>下的这三个para元素</li>
<li>
<code>.//contents/para</code>能在当前路径下，查找到子节点中任何符合<code>contents/para</code>结构的元素</li>
</ul>
<h3>节点属性匹配</h3>
<p>格式：元素[@属性="xxx"]</p>
<ul>
<li>
<code>a[@class="normal-link"]</code>能查找出两个有带normal-link class的a链</li>
<li>
<code>para[a/@class="ex-link"]</code>能查找出一级子元素中有带ex-link class的a链的para元素，这里就是<code>&lt;para&gt;&lt;a href="three.html" class="ex-link"&gt;Three&lt;/a&gt;&lt;/para&gt;</code>
</li>
</ul>
<h3>属性选择</h3>
<p>查找某个元素中的特定属性值，如：<code>a[@class="ex-link"]/@href</code>能读取第三个a链的href值</p>
<h3>内置函数</h3>
<ul>
<li>node()，返回任意种类的节点。比如和内置关键字<code>child</code>组合成<code>/html/body/contents/child::node()</code>，可以选择所有的para节点</li>
<li>text()，返回节点中包含的文本。<code>/html/body/contents/para/a[@class="ex-link"]/text()</code>返回Three。特别的，和模糊路径寻址配合，如<code>/html/body/contents//text()</code>，能返回contents下的<code>One Two Three</code>字符串</li>
</ul>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/da-jian-zhi-neng-fan-qiang-lu-you-qi.html" class="u-url">搭建智能翻墙路由器</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/da-jian-zhi-neng-fan-qiang-lu-you-qi.html" rel="bookmark"><time class="published dt-published" datetime="2015-04-16T08:49:13+08:00" title="2015-04-16 08:49">2015-04-16 08:49</time></a></p>
                <p class="commentline">
        
    <a href="posts/da-jian-zhi-neng-fan-qiang-lu-you-qi.html#disqus_thread" data-disqus-identifier="cache/posts/da-jian-zhi-neng-fan-qiang-lu-you-qi.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>本文着重介绍如何搭建智能翻墙路由器，实现避免DNS污染，并且自动根据是否是国内IP来决定是否翻墙，从而使任何连接路由器的设备无障碍穿墙出去。</p>
<p>思路是，用shadowsocks建立起翻墙代理服务，用shadowsocks的udp relay模式转发DNS请求，解决DNS污染，再配置iptables根据IP决定是否走shadowsocks来翻墙。</p>
<h2>准备材料</h2>
<ul>
<li>能刷OpenWrt的智能路由器。我用的是小米路由器MINI，16MB ROM，128MB DDR2内存，MT7620A处理器，运行毫无压力（真的不是广告。。。）</li>
<li>OpenWrt。这里选的是<a href="http://downloads.openwrt.org.cn/PandoraBox/">PandoraBox</a>版</li>
<li>shadowsocks client，PandoraBox自带</li>
<li>ChinaDNS，PandoraBox自带</li>
<li>VPS一台</li>
<li>shadowsocks server，选用C实现：shadowsocks-libev，go和Python版没有UDP relay功能，不能实现DNS请求转发</li>
</ul>
<h2>步骤</h2>
<h3>shadowsocks server</h3>
<p>shadowsocks-libev的安装参考<a href="http://shadowsocks.org/en/download/servers.html">http://shadowsocks.org/en/download/servers.html</a>中的“C with libev”一节</p>
<p>安装完成之后将如下配置写入config.json</p>
<pre class="code literal-block">{
    "server":"0.0.0.0",
    "server_port":8025,
    "password":"123456",
    "timeout":300,
    "method":"aes-256-cfb"
}
</pre>


<p>分别指定了服务器的binding address，端口，密码，超时时间和加密方式。按需更改</p>
<p>在远程VPS上启动shadowsocks server: <code>ss-server -c config.json -u</code></p>
<p>注意得加上<code>-u</code>选项，enable udprelay mode。用作DNS请求转发，避免DNS污染。</p>
<h3>shadowsocks client</h3>
<p>在本地路由器上起shadowsocks client</p>
<h4>ss-redir</h4>
<p>ss-redir用于将客户端的原始数据封装成shadowsocks协议内容，转发给server，实现透明转发。</p>
<p>在本地路由器启动ss-redir: <code>ss-redir -s "your_server_ip" -p "your_server_port" -l "local_service_port" -m "encryption_method" -k "server_password" -f "pid_file_path"</code>
注意这里不需要<code>-u</code>选项，转发的是TCP包，ss-redir也不支持这个选项。</p>
<h4>ss-tunnel</h4>
<p>ss-tunnel用于实现本地port forward，和ssh的port forward一样，只是加密方式用了shadowsocks协议，用于在本地起服务，转发DNS请求</p>
<p>在本地路由器启动ss-tunnel: <code>ss-tunnel -s "your_server_ip" -p "your_server_port" -l "local_service_port" -m "encryption_method" -k "server_password" -L "server_ip:server_port" -f "pid_file_path" -u</code></p>
<p>这个<code>-L</code>选项理论上可以填国外DNS的IP/PORT，比如<code>8.8.8.8:53</code>，我在我的VPS起了一个DNS转发服务，填了自己的IP/PORT，效果应该一样。<code>-u</code>是开启udp relay，DNS是UDP包嘛</p>
<h3>ChinaDNS</h3>
<p>如果所有DNS请求都走国外DNS server，国内有些网站（如微博）在海外有服务器，就会比较慢。ChinaDNS保证的就是国内域名能解析成国内IP，国外域名解析成国外IP。</p>
<p>在本地路由器启动ChinaDNS: <code>chinadns -l /etc/chinadns_iplist.txt -c /etc/chinadns_chnroute.txt -d -p "local_dns_port" -s 114.114.114.114,127.0.0.1:8026</code></p>
<p><code>-s</code>选项后加以逗号分隔的DNS服务器列表，最好国内、国外各有一个。由于前面通过ss-tunnel在本地起了一个端口转发到我的DNS服务，所以填的是<code>127.0.0.1:8026</code>。</p>
<p>ChinaDNS原理是，向所有列表中的DNS server发DNS请求，判断结果可信任条件是：国内DNS解析出的是国内IP，国外DNS解析出的是国外IP，<code>/etc/chinadns_chnroute.txt</code>里包含了国内IP网段，<code>/etc/chinadns_iplist.txt</code>里包含的是常见的被污染后的DNS解析结果IP。这样只要通过<code>dnsmasq</code>之类的把本地DNS请求转发到ChinaDNS的端口上，就能解决DNS污染的问题。</p>
<h3>iptables</h3>
<p>前面的准备工作完成之后，只要配置一下iptables，将国内TCP流量直接放行，国外TCP流量转发到ss-redir起的端口就行，判断依据是IP。</p>
<p>在nat表中新建一个SHADOWSOCKS链</p>
<pre class="code literal-block">iptables -t nat -N SHADOWSOCKS
</pre>


<p>远程VPS流量直接放行</p>
<pre class="code literal-block">iptables -t nat -A SHADOWSOCKS -d xxx.xxx.xx.xxx -j RETURN
</pre>


<p>内网流量直接放行</p>
<pre class="code literal-block">iptables -t nat -A SHADOWSOCKS -d 0.0.0.0/8 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 10.0.0.0/8 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 127.0.0.0/8 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 169.254.0.0/16 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 172.16.0.0/12 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 192.168.0.0/16 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 224.0.0.0/4 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 240.0.0.0/4 -j RETURN
</pre>


<p>国内IP流量直接放行(列表较长，这里不列举了，网上随便搜搜就有)</p>
<p>剩下的TCP流量转发到ss-redir端口</p>
<pre class="code literal-block">iptables -t nat -A SHADOWSOCKS -p tcp -j REDIRECT --to-ports xxx
</pre>


<h2>完工</h2>
<p>搞定之后，任何连接这个路由器的设备都能实现透明翻墙了。</p>
<p>以上</p>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/guan-yu-pythonyi-chang-chu-li-liu-cheng.html" class="u-url">关于Python异常处理流程</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/guan-yu-pythonyi-chang-chu-li-liu-cheng.html" rel="bookmark"><time class="published dt-published" datetime="2014-10-23T12:27:56+08:00" title="2014-10-23 12:27">2014-10-23 12:27</time></a></p>
                <p class="commentline">
        
    <a href="posts/guan-yu-pythonyi-chang-chu-li-liu-cheng.html#disqus_thread" data-disqus-identifier="cache/posts/guan-yu-pythonyi-chang-chu-li-liu-cheng.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<pre class="code literal-block"><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">'try'</span>
        <span class="k">raise</span> <span class="ne">NameError</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">'except'</span>
        <span class="k">raise</span> <span class="ne">KeyError</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">'else'</span>
        <span class="k">raise</span> <span class="ne">IOError</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">'finally'</span>
        <span class="k">raise</span> <span class="ne">ValueError</span>
</pre>


<p>在以上代码中，无论try里有没有异常，走得是except还是else，最终抛出的都是finally中的ValueError。为此小记一下Python里的异常处理流程。</p>
<p>Python当前状态的异常信息存储在线程状态PyThreadState中，包括type, value, traceback。无论是主动raise还是bug触发，异常信息最终都会通过PyErr_Restore(Python/errors.c)被修改。</p>
<p>异常处理的主要流程在PyEval_EvalFrameEx(Python/ceval.c)里，也是Python虚拟机的核心处理流程。</p>
<p>先说明几个概念以便理解：</p>
<ol>
<li>Python虚拟机里PyEval_EvalFrameEx干的活就是物理机里CPU干的活，根据指令作出相应动作</li>
<li>frame：一个函数的执行环境，可以理解为物理机上EBP, ESP等寄存器确定的函数调用栈，外加一点别的状态信息</li>
<li>blockstack：也是一个栈，隶属于一个frame。每当遇到循环或者try异常处理块都会压入一个block对象，块流程完了弹出</li>
<li>traceback：一个链表，记录发生异常时候的调用栈信息</li>
</ol>
<pre class="code literal-block"><span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyEval_EvalFrameEx</span><span class="p">(</span><span class="n">PyFrameObject</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">throwflag</span><span class="p">)</span>
<span class="p">{</span>

     <span class="k">register</span> <span class="k">enum</span> <span class="n">why_code</span> <span class="n">why</span><span class="p">;</span> <span class="c1">// 每一条指令处理完之后的状态，用来标记是否有异常</span>

     <span class="k">switch</span><span class="p">(</span><span class="n">opcode</span><span class="p">){}</span> <span class="c1">// 一个处理字节码指令的巨大switch</span>
     <span class="p">...</span>

     <span class="c1">// 记录traceback，用来在异常最终没有处理时打印调用栈信息</span>
     <span class="c1">// 这个why ==WHY_EXCEPTION条件很重要，如果在finally中发生异常，则why的值是WHY_RERAISE，因此不会进入这个条件记录新的traceback，而是直接覆盖当前的traceback，所以在最终的调用栈里，finally异常之前try/except/else中的异常信息也就被覆盖了</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">why</span> <span class="o">==</span> <span class="n">WHY_EXCEPTION</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PyTraceBack_Here</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">c_tracefunc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="n">call_exc_trace</span><span class="p">(</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">c_tracefunc</span><span class="p">,</span>
                               <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">c_traceobj</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
        <span class="p">}</span>

     <span class="c1">// 这种是finally中有异常的状态，reraise</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">why</span> <span class="o">==</span> <span class="n">WHY_RERAISE</span><span class="p">)</span>
            <span class="n">why</span> <span class="o">=</span> <span class="n">WHY_EXCEPTION</span><span class="p">;</span>

     <span class="c1">// 栈帧展开，主要为了在当前frame，沿着block栈向上寻找有没有try/except来接住异常</span>

<span class="nl">fast_block_end</span><span class="p">:</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">why</span> <span class="o">!=</span> <span class="n">WHY_NOT</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_iblock</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* Peek at the current block. */</span>
            <span class="n">PyTryBlock</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_blockstack</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_iblock</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

           <span class="p">......</span>

            <span class="cm">/* Now we have to pop the block. */</span>
            <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_iblock</span><span class="o">--</span><span class="p">;</span>

           <span class="p">......</span>

          <span class="c1">// 在finally块中</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">b_type</span> <span class="o">==</span> <span class="n">SETUP_FINALLY</span> <span class="o">||</span>
                <span class="p">......</span>
                <span class="p">)</span> <span class="p">{</span>

               <span class="c1">// 有异常(raise xxxError或bug触发的情况)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">why</span> <span class="o">==</span> <span class="n">WHY_EXCEPTION</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">PyObject</span> <span class="o">*</span><span class="n">exc</span><span class="p">,</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="o">*</span><span class="n">tb</span><span class="p">;</span>

                    <span class="c1">// 取出异常信息，压入执行栈</span>
                    <span class="n">PyErr_Fetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tb</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">tb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">Py_None</span><span class="p">);</span>
                        <span class="n">PUSH</span><span class="p">(</span><span class="n">Py_None</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span>
                        <span class="n">PUSH</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
                    <span class="n">PUSH</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
                    <span class="n">PUSH</span><span class="p">(</span><span class="n">exc</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// return或者continue语句</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">why</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">WHY_RETURN</span> <span class="o">|</span> <span class="n">WHY_CONTINUE</span><span class="p">))</span>
                        <span class="n">PUSH</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">PyInt_FromLong</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">why</span><span class="p">);</span>
                    <span class="n">PUSH</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
                <span class="p">}</span>
               <span class="c1">// 跳转到END_FINALLY指令进行扫尾工作</span>
                <span class="n">why</span> <span class="o">=</span> <span class="n">WHY_NOT</span><span class="p">;</span>
                <span class="n">JUMPTO</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">b_handler</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="cm">/* unwind stack */</span>

     <span class="c1">// 函数返回值为null说明函数中发生异常未处理</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">why</span> <span class="o">!=</span> <span class="n">WHY_RETURN</span><span class="p">)</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

     <span class="c1">// 栈帧回退，取回上一层函数执行信息</span>

    <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_back</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>补充一点：</p>
<p>dis模块可以“反汇编”Python字节码变成“Python汇编语言”，下面就是示例代码的反汇编结果：</p>
<pre class="code literal-block">  6           0 SETUP_FINALLY           63 (to 66)
              3 SETUP_EXCEPT            15 (to 21)

  7           6 LOAD_CONST               1 ('try')
              9 PRINT_ITEM
             10 PRINT_NEWLINE

  8          11 LOAD_GLOBAL              0 (NameError)
             14 RAISE_VARARGS            1
             17 POP_BLOCK
             18 JUMP_FORWARD            30 (to 51)

  9     &gt;&gt;   21 DUP_TOP
             22 LOAD_GLOBAL              1 (Exception)
             25 COMPARE_OP              10 (exception match)
             28 POP_JUMP_IF_FALSE       50
             31 POP_TOP
             32 STORE_FAST               0 (e)
             35 POP_TOP

 10          36 LOAD_CONST               2 ('except')
             39 PRINT_ITEM
             40 PRINT_NEWLINE

 11          41 LOAD_GLOBAL              2 (KeyError)
             44 RAISE_VARARGS            1
             47 JUMP_FORWARD            12 (to 62)
        &gt;&gt;   50 END_FINALLY

 13     &gt;&gt;   51 LOAD_CONST               3 ('else')
             54 PRINT_ITEM
             55 PRINT_NEWLINE

 14          56 LOAD_GLOBAL              3 (IOError)
             59 RAISE_VARARGS            1
        &gt;&gt;   62 POP_BLOCK
             63 LOAD_CONST               0 (None)

 16     &gt;&gt;   66 LOAD_CONST               4 ('finally')
             69 PRINT_ITEM
             70 PRINT_NEWLINE

 17          71 LOAD_GLOBAL              4 (ValueError)
             74 RAISE_VARARGS            1
             77 END_FINALLY
             78 LOAD_CONST               0 (None)
             81 RETURN_VALUE
</pre>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/innodbyin-qing-suo-yin-xue-xi-bi-ji.html" class="u-url">InnoDB引擎索引学习笔记</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/innodbyin-qing-suo-yin-xue-xi-bi-ji.html" rel="bookmark"><time class="published dt-published" datetime="2013-11-16T19:31:34+08:00" title="2013-11-16 19:31">2013-11-16 19:31</time></a></p>
                <p class="commentline">
        
    <a href="posts/innodbyin-qing-suo-yin-xue-xi-bi-ji.html#disqus_thread" data-disqus-identifier="cache/posts/innodbyin-qing-suo-yin-xue-xi-bi-ji.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>最近在研究学习MySQL，本文记录下索引相关（主要B-Tree索引）的特性。</p>
<hr>
<h3>索引是什么</h3>
<p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。</p>
<p>按所用的数据结构分，有B-Tree索引（B+ Tree）、哈希索引、R-Tree索引等。按数据块的顺序和索引节点的逻辑顺序是否一致可以分为聚集索引和非聚集索引。聚集索引由于物理块连续，在范围扫描的时候可以减少磁头寻道时间，因而比非聚集索引高效。</p>
<h3>InnoDB索引结构</h3>
<p>InnoDB引擎的索引主体结构是B+Tree（这种数据结构的描述可以参考CSDN博主v_JULY_v的<a href="http://blog.csdn.net/v_JULY_v/article/details/6530142">从B树、B+树、B*树谈到R 树</a>）。</p>
<p>其中，主键索引(Primary Index)是聚集索引，中间节点是用于查询的边界值，叶子节点就是数据节点，叶子节点之间通过指针形成双向链表。如图：</p>
<p><img alt="primary_index.jpg" src="galleries/InnoDB/primary_index.jpg" title=""></p>
<p>辅助索引(Secondary Index)同样为B-Tree索引，只是叶子节点不是数据节点，而是对主键的引用。</p>
<p><img alt="secondary_index.jpg" src="galleries/InnoDB/secondary_index.jpg" title=""></p>
<p>由于此特性，InnoDB引擎要求数据表必须有一个主键，如果没有主键，在数据表创建的时候会自动生成一个唯一非空索引替代。这个特性也决定了InnoDB表的主键最好是一个自增的ID序列，这样在后续插入的过程中不会造成数据块的唯一，提升性能。</p>
<p>当所建立的索引为多列索引的时候，例如KEY(a,b,c)，中间节点依旧以最左边的一列a进行索引，只是在叶子节点上保存的不仅仅是a，而是(a,b,c)多字段排序后的序列。</p>
<h3>性能实测</h3>
<p>下面结合实际例子阐述现象和内部结构的关系</p>
<p>首先建立一个测试表：</p>
<pre class="code literal-block"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">test</span> <span class="p">(</span>
     <span class="n">id</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
     <span class="n">a</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
     <span class="n">b</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
     <span class="k">c</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
     <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
     <span class="k">KEY</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="k">c</span><span class="p">)</span>
<span class="p">)</span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>
</pre>


<p>数据项为(a,b,c)在0~200之间的所有组合项，共计8000000行记录。为了消除几次实验中以query cache为代表的各种server cache对实验数据的影响，每次实验后均重启mysql服务。</p>
<h4>索引对查询效率的影响</h4>
<p>首先是建立KEY(a,b,c)索引前后的性能对比，能很明显地看到索引大幅提升查询速度。没有索引的时候需要做全表扫描，建立索引之后通过B-Tree搜索。</p>
<pre class="code literal-block">没有索引（除主键，下同）
[SQL]select * from test where a = 0 and b = 1;
Affected rows: 0
Time: 0.324s

建立KEY(a,b,c)
[SQL]select * from test where a = 0 and b = 1;
Affected rows: 0
Time: 0.004s
</pre>


<p>由于MySQL优化器的优化，where条件中的各个子条件顺序对索引的使用没有影响。</p>
<pre class="code literal-block">[SQL]select * from test where b = 1 and a = 0;
Affected rows: 0
Time: 0.002s
</pre>


<p>当使用的列非严格的索引最左前缀时，可以想象，只有a加速了索引搜索，找到所有符合a条件的记录的之后只能顺序扫描检查c是否符合条件。所以相比没有索引时要快，但是慢于使用严格索引最左前缀时的速度。</p>
<pre class="code literal-block">[SQL]select * from test where a = 0 and c = 1;
Affected rows: 0
Time: 0.043s
</pre>


<p>当没有使用到a列作为条件时完全没法使用索引，甚至比没有索引时还要慢。因为建表的时候a在前，b、c在后，并且数据节点有序。在没有索引的测试中，InnoDB引擎到a不为0时自动停止搜索。而在这个例子中需要扫描全表找出满足符合条件的b、c，达到完全没法忍受的16秒。</p>
<pre class="code literal-block">[SQL]select * from test where b = 0 and c = 1;
Affected rows: 0
Time: 16.023s
</pre>


<h4>索引对排序效率的影响</h4>
<p>只要能用到索引，并且ORDER BY后面的列在索引中，则顺序还是倒序排序对性能无影响。因为叶子节点是个双向链表，倒序可以从后向前遍历，与顺序的代价相同。</p>
<pre class="code literal-block">[SQL]select * from test where a = 0 ORDER BY b;
Affected rows: 0
Time: 0.085s

[SQL]select * from test where a = 0 ORDER BY b DESC;
Affected rows: 0
Time: 0.089s
</pre>


<p>但是，当有两个字段排序的顺序不同时，叶子节点的有序性就无法用在排序中，必须读出所有叶子节点之后再按指定的字段进行一趟排序，所以速度就慢了下来。</p>
<pre class="code literal-block">[SQL]select * from test where a = 0 ORDER BY b DESC, c DESC;
Affected rows: 0
Time: 0.089s

[SQL]select * from test where a = 0 ORDER BY b ASC, c DESC;
Affected rows: 0
Time: 0.184s
</pre>


<p>同样，下面的例子中对索引左边的字段a进行范围选择的时候也没法运用索引，因为多个取值的a无法保证b和c字段有序，必须重新排序</p>
<pre class="code literal-block">[SQL]select * from test where a &lt;= 0 ORDER BY b;
Affected rows: 0
Time: 0.103s
</pre>


<p>所以，尽可能做到覆盖索引（即where，order by中用到的字段被索引覆盖），能利用索引加速搜索和排序。</p>
<hr>
<p>参考资料：</p>
<p>《高性能MySQL》，电子工业出版社，2010年1月</p>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/pythonla-ji-hui-shou-ji-zhi.html" class="u-url">Python垃圾回收机制</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/pythonla-ji-hui-shou-ji-zhi.html" rel="bookmark"><time class="published dt-published" datetime="2013-10-24T10:44:52+08:00" title="2013-10-24 10:44">2013-10-24 10:44</time></a></p>
                <p class="commentline">
        
    <a href="posts/pythonla-ji-hui-shou-ji-zhi.html#disqus_thread" data-disqus-identifier="cache/posts/pythonla-ji-hui-shou-ji-zhi.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>题记：我是来填坑的。。。</p>
<p>本文主要结合CPython源码分析一下Python的GC机制（面试的时候被问到这个问题，之前理解不深，答得不好，一波大坑啊。。。）</p>
<hr>
<p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p>
<h3>引用计数</h3>
<p>引用计数法在对象内部维护了一个被其他对象引用数的引用计数值，当这个引用计数值为0时，说明这个对象不再被其他对象引用，就可以被回收了。</p>
<p>结合源码来看，所有Python对象的头部包含了这样一个结构PyObject（相当于继承自PyObject）：</p>
<pre class="code literal-block"><span class="c1">// object.h</span>
<span class="k">struct</span> <span class="n">_object</span> <span class="p">{</span>
    <span class="n">Py_ssize_t</span> <span class="n">ob_refcnt</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">ob_type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyObject</span><span class="p">;</span>
</pre>


<p>ob_refcnt就是引用计数值。</p>
<p>例如，下面是int型对象的定义：</p>
<pre class="code literal-block"><span class="c1">// intobject.h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">PyObject_HEAD</span>
        <span class="kt">long</span> <span class="n">ob_ival</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyIntObject</span><span class="p">;</span>
</pre>


<p>引用计数法有很明显的优点：</p>
<ol>
<li>高效</li>
<li>运行期没有停顿</li>
<li>对象有确定的生命周期</li>
<li>易于实现</li>
</ol>
<p>原始的引用计数法也有明显的缺点：</p>
<ol>
<li>维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。</li>
<li>无法解决循环引用的问题。A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数都为1，但显然应该被回收。</li>
</ol>
<p>为了解决这两个致命弱点，Python又引入了以下两种GC机制。</p>
<h3>标记-清除</h3>
<p>“标记-清除”法是为了解决循环引用问题。可以包含其他对象引用的容器对象（如list, dict, set，甚至class）都可能产生循环引用，为此，在申请内存时，所有容器对象的头部又加上了<code>PyGC_Head</code>来实现“标记-清除”机制。</p>
<pre class="code literal-block"><span class="c1">// objimpl.h</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">_gc_head</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="k">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_next</span><span class="p">;</span>
        <span class="k">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_prev</span><span class="p">;</span>
        <span class="n">Py_ssize_t</span> <span class="n">gc_refs</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">gc</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">double</span> <span class="n">dummy</span><span class="p">;</span>  <span class="cm">/* force worst-case alignment */</span>
<span class="p">}</span> <span class="n">PyGC_Head</span><span class="p">;</span>
</pre>


<p>在为对象申请内存的时候，可以明显看到，实际申请的内存数量已经加上了PyGC_Head的大小</p>
<pre class="code literal-block"><span class="c1">// gcmodule.c</span>
<span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">_PyObject_GC_Malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">basicsize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="p">)</span><span class="n">PyObject_MALLOC</span><span class="p">(</span>
                <span class="k">sizeof</span><span class="p">(</span><span class="n">PyGC_Head</span><span class="p">)</span> <span class="o">+</span> <span class="n">basicsize</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">g</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>

    <span class="p">......</span>

    <span class="n">op</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>举例来说，从<code>list</code>对象的创建中，有如下主要逻辑：</p>
<pre class="code literal-block"><span class="c1">// listobject.c</span>
<span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyList_New</span><span class="p">(</span><span class="n">Py_ssize_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyListObject</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
    <span class="p">......</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">PyObject_GC_New</span><span class="p">(</span><span class="n">PyListObject</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PyList_Type</span><span class="p">);</span>
    <span class="p">......</span>
    <span class="n">_PyObject_GC_TRACK</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p><code>_PyObject_GC_TRACK</code>就将对象链接到了第0代对象集合中（后文详述分代回收）。</p>
<p>垃圾标记时，先将集合中对象的引用计数复制一份副本(以免在操作过程中破坏真实的引用计数值)：</p>
<pre class="code literal-block"><span class="c1">// gcmodule.c</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">update_refs</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">containers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">containers</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">gc</span> <span class="o">!=</span> <span class="n">containers</span><span class="p">;</span> <span class="n">gc</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">==</span> <span class="n">GC_REACHABLE</span><span class="p">);</span>
        <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ob_refcnt</span><span class="p">;</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>


<p>然后操作这个副本，遍历对象集合，将被引用对象的引用计数副本值减1：</p>
<pre class="code literal-block"><span class="c1">// gcmodule.c</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">subtract_refs</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">containers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">traverseproc</span> <span class="n">traverse</span><span class="p">;</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">containers</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">gc</span> <span class="o">!=</span> <span class="n">containers</span><span class="p">;</span> <span class="n">gc</span><span class="o">=</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">traverse</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_traverse</span><span class="p">;</span>
        <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">traverse</span><span class="p">(</span><span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">),</span>
                   <span class="p">(</span><span class="n">visitproc</span><span class="p">)</span><span class="n">visit_decref</span><span class="p">,</span>
                   <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>


<p>这个<code>traverse</code>是对象类型定义的函数，用来遍历对象，通过传入的回调函数<code>visit_decref</code>来操作引用计数副本。</p>
<p>例如<code>dict</code>就要在key和value上都用<code>visit_decref</code>操作一遍：</p>
<pre class="code literal-block"><span class="c1">// dictobject.c</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">dict_traverse</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_ssize_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">pk</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">pv</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">PyDict_Next</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pv</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">visit</span><span class="p">(</span><span class="n">pk</span><span class="p">);</span>
        <span class="n">visit</span><span class="p">(</span><span class="n">pv</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>然后根据引用计数副本值是否为0将集合内的对象分成两类，reachable和unreachable，其中unreachable是可以被回收的对象：</p>
<pre class="code literal-block"><span class="c1">// gcmodule.c</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">move_unreachable</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">young</span><span class="p">,</span> <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">unreachable</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">young</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">gc</span> <span class="o">!=</span> <span class="n">young</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">);</span>
            <span class="n">traverseproc</span> <span class="n">traverse</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_traverse</span><span class="p">;</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">GC_REACHABLE</span><span class="p">;</span>
            <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">traverse</span><span class="p">(</span><span class="n">op</span><span class="p">,</span>
                            <span class="p">(</span><span class="n">visitproc</span><span class="p">)</span><span class="n">visit_reachable</span><span class="p">,</span>
                            <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">young</span><span class="p">);</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
            <span class="n">gc_list_move</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">unreachable</span><span class="p">);</span>
            <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">GC_TENTATIVELY_UNREACHABLE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">gc</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>


<p>在处理了weak reference和finalizer等琐碎细节后（本文不展开讲述，有兴趣的童鞋请参考python源码），就可以回收unreachable中的对象了。</p>
<h3>分代回收</h3>
<p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p>
<p>用来表示“代”的结构体是<code>gc_generation</code>， 包括了当前代链表表头、对象数量上限、当前对象数量：</p>
<pre class="code literal-block"><span class="c1">// gcmodule.c</span>
<span class="k">struct</span> <span class="n">gc_generation</span> <span class="p">{</span>
    <span class="n">PyGC_Head</span> <span class="n">head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">threshold</span><span class="p">;</span> <span class="cm">/* collection threshold */</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span> <span class="cm">/* count of allocations or collections of younger</span>
<span class="cm">              generations */</span>
<span class="p">};</span>
</pre>


<p>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。</p>
<pre class="code literal-block"><span class="cp">#define NUM_GENERATIONS 3</span>
<span class="cp">#define GEN_HEAD(n) (&amp;generations[n].head)</span>

<span class="cm">/* linked lists of container objects */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gc_generation</span> <span class="n">generations</span><span class="p">[</span><span class="n">NUM_GENERATIONS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/* PyGC_Head,               threshold,  count */</span>
    <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>   <span class="mi">700</span><span class="p">,</span>        <span class="mi">0</span><span class="p">},</span>
    <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>   <span class="mi">10</span><span class="p">,</span>     <span class="mi">0</span><span class="p">},</span>
    <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>   <span class="mi">10</span><span class="p">,</span>     <span class="mi">0</span><span class="p">},</span>
<span class="p">};</span>
</pre>


<p>新生成的对象会被加入第0代，前面<code>_PyObject_GC_Malloc</code>中省略的部分就是Python GC触发的时机。每新生成一个对象都会检查第0代有没有满，如果满了就开始着手进行垃圾回收：</p>
<pre class="code literal-block"> <span class="n">g</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">GC_UNTRACKED</span><span class="p">;</span>
 <span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* number of allocated GC objects */</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&amp;&amp;</span>
     <span class="n">enabled</span> <span class="o">&amp;&amp;</span>
     <span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&amp;&amp;</span>
     <span class="o">!</span><span class="n">collecting</span> <span class="o">&amp;&amp;</span>
     <span class="o">!</span><span class="n">PyErr_Occurred</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">collecting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">collect_generations</span><span class="p">();</span>
          <span class="n">collecting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</pre>


<hr>
<p>参考资料：</p>
<ol>
<li>《Python源码剖析》，陈儒著，2008</li>
<li>Wikipedia - Reference counting: <a href="http://en.wikipedia.org/wiki/Reference_counting">http://en.wikipedia.org/wiki/Reference_counting</a>
</li>
<li>Wikipedia - Garbage collection: <a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</a>
</li>
</ol>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/li-yong-ld_preloadjin-xing-hook.html" class="u-url">利用LD_PRELOAD进行hook</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/li-yong-ld_preloadjin-xing-hook.html" rel="bookmark"><time class="published dt-published" datetime="2013-10-09T11:44:50+08:00" title="2013-10-09 11:44">2013-10-09 11:44</time></a></p>
                <p class="commentline">
        
    <a href="posts/li-yong-ld_preloadjin-xing-hook.html#disqus_thread" data-disqus-identifier="cache/posts/li-yong-ld_preloadjin-xing-hook.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>好久没玩hook这种猥琐的东西里，今天在Linux下体验了一把。</p>
<p>loader在进行动态链接的时候，会将有相同符号名的符号覆盖成LD_PRELOAD指定的so文件中的符号。换句话说，可以用我们自己的so库中的函数替换原来库里有的函数，从而达到hook的目的。这和Windows下通过修改import table来hook API很类似。相比较之下，LD_PRELOAD更方便了，都不用自己写代码了，系统的loader会帮我们搞定。但是LD_PRELOAD有个限制：只能hook动态链接的库，对静态链接的库无效，因为静态链接的代码都写到可执行文件里了嘛，没有坑让你填。</p>
<p>上代码</p>
<p>先是受害者，我们的主程序main.c，通过strcmp比较字符串是否相等：</p>
<pre class="code literal-block"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"test"</span><span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Incorrect password</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Correct password</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>然后是用来hook的库hook.c：</p>
<pre class="code literal-block"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;dlfcn.h&gt;</span>

<span class="k">typedef</span> <span class="nf">int</span><span class="p">(</span><span class="o">*</span><span class="n">STRCMP</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">strcmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">STRCMP</span> <span class="n">old_strcmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">handle</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="s">"libc.so.6"</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
        <span class="n">old_strcmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">STRCMP</span><span class="p">)</span><span class="n">dlsym</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">"strcmp"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hack function invoked. s1=&lt;%s&gt; s2=&lt;%s&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">old_strcmp</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>
<span class="p">}</span>
</pre>


<p>因为hook的目标是strcmp，所以typedef了一个STRCMP函数指针。由于hook的目的是要控制函数行为，所以需要从原库libc.so.6中拿到“正版”strcmp指针，保存成old_strcmp以备调用。</p>
<p>Makefile：</p>
<pre class="code literal-block"><span class="nb">test</span>: main.c hook.so
    gcc -o <span class="nb">test </span>main.c

hook.so: hook.c
    gcc -fPIC -shared -o hook.so hook.c -ldl
</pre>


<p>执行：</p>
<pre class="code literal-block"><span class="nv">$ LD_PRELOAD</span><span class="o">=</span>./hook.so ./test 123
hack <span class="k">function</span> invoked. <span class="nv">s1</span><span class="o">=</span>&lt;123&gt; <span class="nv">s2</span><span class="o">=</span>&lt;<span class="nb">test</span>&gt;
Incorrect password

<span class="nv">$ LD_PRELOAD</span><span class="o">=</span>./hook.so ./test <span class="nb">test</span>
hack <span class="k">function</span> invoked. <span class="nv">s1</span><span class="o">=</span>&lt;<span class="nb">test</span>&gt; <span class="nv">s2</span><span class="o">=</span>&lt;<span class="nb">test</span>&gt;
Correct password
</pre>


<p>其中有一点不理解的是，<code>dlopen</code>打开libc.so.6能拿到“正版”strcmp地址，打开libc.so就是hook后的地址。照理说libc.so不是libc.so.6的一个软链吗？为什么结果会不一样嘞？</p>
<hr>
<p>参考资料：</p>
<p><a href="http://www.exploit-db.com/papers/13233/">Reverse Engineering with LD_PRELOAD</a></p>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/linuxxia-bian-yi-lian-jie-dong-tai-ku.html" class="u-url">Linux下编译链接动态库</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/linuxxia-bian-yi-lian-jie-dong-tai-ku.html" rel="bookmark"><time class="published dt-published" datetime="2013-10-08T09:18:31+08:00" title="2013-10-08 09:18">2013-10-08 09:18</time></a></p>
                <p class="commentline">
        
    <a href="posts/linuxxia-bian-yi-lian-jie-dong-tai-ku.html#disqus_thread" data-disqus-identifier="cache/posts/linuxxia-bian-yi-lian-jie-dong-tai-ku.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>记录下Linux下编译和链接动态库的过程。</p>
<h3>一、 编写动态库</h3>
<p>头文件so.h：  </p>
<pre class="code literal-block"><span class="cp">#ifndef  SO_H</span>
<span class="cp">#define  SO_H</span>

<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>


<span class="cp">#endif  </span><span class="cm">/*SO_H*/</span><span class="cp"></span>
</pre>


<p>实现文件so.c：</p>
<pre class="code literal-block"><span class="cp">#include "so.h"</span>

<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<h3>二、编译动态库</h3>
<pre class="code literal-block">gcc so.c -fPIC -shared -o libtest.so
</pre>


<p>解释一下各个参数含义：</p>
<ol>
<li>-fPIC：生成位置无关代码(<a href="http://en.wikipedia.org/wiki/Position-independent_code">Position Independent Code</a>)，只有生成PIC才能通过虚拟页映射达到可执行代码在进程间共享，从而节省内存的目的。</li>
<li>说明我们要生成的是动态库so(Shared Object)文件，从而进行动态链接。</li>
</ol>
<p>通过<code>nm -g libtest.so</code>可以看到，导出符号表中已经有<code>add</code>这个符号了：</p>
<pre class="code literal-block"><span class="nv">$ </span>nm -g libtest.so 
<span class="m">0000000000000670</span> T add
<span class="m">0000000000201030</span> B __bss_start
                 w __cxa_finalize@@GLIBC_2.2.5
<span class="m">0000000000201030</span> D _edata
<span class="m">0000000000201038</span> B _end
<span class="m">0000000000000684</span> T _fini
                 w __gmon_start__
<span class="m">0000000000000540</span> T _init
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
                 w _Jv_RegisterClasses
</pre>


<h3>三、使用动态库</h3>
<h4>1. 隐式链接(编译时链接)</h4>
<p>编写主程序main.c：</p>
<pre class="code literal-block"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include "so.h"</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>使用<code>gcc main.c -L. -ltest -o test</code>进行编译。</p>
<ul>
<li>-L：添加库文件的搜索路径</li>
<li>-l：指定需要链接的库。该名称是处在头lib和后缀.so中的名称，如上动态库libtest.so的l参数为-l test</li>
</ul>
<p>此时通过<code>readelf test -d</code>已经能看到生成的可执行文件test的Dynamic section里依赖libtest.so了</p>
<pre class="code literal-block"><span class="nv">$ </span>readelf <span class="nb">test</span> -d

Dynamic section at offset 0xe18 contains <span class="m">25</span> entries:
  Tag        Type                         Name/Value
 0x0000000000000001 <span class="o">(</span>NEEDED<span class="o">)</span>             Shared library: <span class="o">[</span>libtest.so<span class="o">]</span>
 0x0000000000000001 <span class="o">(</span>NEEDED<span class="o">)</span>             Shared library: <span class="o">[</span>libc.so.6<span class="o">]</span>
......
</pre>


<p>dynamic symbols中也有一个undefined symbol(add)</p>
<pre class="code literal-block"><span class="nv">$ </span>nm -D <span class="nb">test </span>
<span class="nb">                 </span>U add
<span class="m">0000000000601048</span> B __bss_start
<span class="m">0000000000601048</span> D _edata
<span class="m">0000000000601050</span> B _end
00000000004007b4 T _fini
                 w __gmon_start__
<span class="m">0000000000400578</span> T _init
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
                 w _Jv_RegisterClasses
                 U __libc_start_main
                 U <span class="nb">printf</span>
</pre>


<p>在执行隐式链接的程序之前要注意设置<code>LD_LIBRARY_PATH</code>环境变量，或者把前面生成的libtest.so复制到系统路径下，否则会找不到动态库。</p>
<pre class="code literal-block"><span class="nv">$ </span>./test 
./test: error <span class="k">while</span> loading shared libraries: libtest.so: cannot open shared object file: No such file or directory

<span class="nv">$ </span><span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span>.

<span class="nv">$ </span>./test 
3
</pre>


<h4>2. 显式链接(运行时链接)</h4>
<p>编写主程序dyn_main.c</p>
<pre class="code literal-block"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;dlfcn.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">dl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">add</span><span class="p">)(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">dl</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span> <span class="s">"./libtest.so"</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">dl</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"so loading error.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">add</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span><span class="n">dlsym</span><span class="p">(</span><span class="n">dl</span><span class="p">,</span> <span class="s">"add"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">dlerror</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"fun load error.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>使用<code>gcc dyn_main.c -ldl -o dyn_test</code>编译。</p>
<p>这时通过<code>readelf dyn_test -d</code>可以发现，dyn_test不依赖libtest.so：</p>
<pre class="code literal-block"><span class="nv">$ </span>readelf dyn_test -d

Dynamic section at offset 0xe18 contains <span class="m">25</span> entries:
  Tag        Type                         Name/Value
 0x0000000000000001 <span class="o">(</span>NEEDED<span class="o">)</span>             Shared library: <span class="o">[</span>libdl.so.2<span class="o">]</span>
 0x0000000000000001 <span class="o">(</span>NEEDED<span class="o">)</span>             Shared library: <span class="o">[</span>libc.so.6<span class="o">]</span>
......
</pre>


<p>dyn_test的dynamic symbols中也没有add：</p>
<pre class="code literal-block"><span class="nv">$ </span>nm -D dyn_test 
                 U dlerror
                 U dlopen
                 U dlsym
                 w __gmon_start__
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
                 w _Jv_RegisterClasses
                 U __libc_start_main
                 U <span class="nb">printf</span>
<span class="nb">                 </span>U puts
</pre>


<p>运行程序也不需要设置<code>LD_LIBRARY_PATH</code>环境变量</p>
<pre class="code literal-block"><span class="nv">$ </span>./dyn_test 
3
</pre>


<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://hi.baidu.com/linuxlife/item/ed8e5d0c6e86b491a2df4366">Linux动态库的编译与使用 转载</a></li>
<li><a href="http://os.51cto.com/art/201003/186246.htm">详细分析Linux动态库的使用方式</a></li>
<li><a href="http://stackoverflow.com/questions/34732/how-do-i-list-the-symbols-in-a-so-file">How do I list the symbols in a .so file</a></li>
<li><a href="http://stackoverflow.com/questions/10480657/import-names-in-elf-binary">Import names in ELF binary</a></li>
</ol>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/cyu-yan-hong-de-te-shu-yong-fa-he-ji-ge-keng.html" class="u-url">C语言宏的特殊用法和几个坑</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/cyu-yan-hong-de-te-shu-yong-fa-he-ji-ge-keng.html" rel="bookmark"><time class="published dt-published" datetime="2013-07-13T14:25:31+08:00" title="2013-07-13 14:25">2013-07-13 14:25</time></a></p>
                <p class="commentline">
        
    <a href="posts/cyu-yan-hong-de-te-shu-yong-fa-he-ji-ge-keng.html#disqus_thread" data-disqus-identifier="cache/posts/cyu-yan-hong-de-te-shu-yong-fa-he-ji-ge-keng.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>总结一下C语言中宏的一些特殊用法和几个容易踩的坑。由于本文主要参考GCC文档，某些细节（如宏参数中的空格是否处理之类）在别的编译器可能有细微差别，请参考相应文档。</p>
<h3>宏基础</h3>
<p>宏仅仅是在C预处理阶段的一种文本替换工具，编译完之后对二进制代码不可见。基本用法如下：</p>
<h4>1. 标示符别名</h4>
<pre class="code literal-block"><span></span><span class="cp">#define BUFFER_SIZE 1024</span>
</pre>


<p>预处理阶段，<code>foo = (char *) malloc (BUFFER_SIZE);</code>会被替换成<code>foo = (char *) malloc (1024);</code></p>
<p>宏体换行需要在行末加反斜杠\</p>
<pre class="code literal-block"><span></span><span class="cp">#define NUMBERS 1, \</span>
<span class="cp">                2, \</span>
<span class="cp">                3</span>
</pre>


<p>预处理阶段<code>int x[] = { NUMBERS };</code>会被扩展成<code>int x[] = { 1, 2, 3 };</code></p>
<h4>2. 宏函数</h4>
<p>宏名之后带括号的宏被认为是宏函数。用法和普通函数一样，只不过在预处理阶段，宏函数会被展开。优点是没有普通函数保存寄存器和参数传递的开销，展开后的代码有利于CPU cache的利用和指令预测，速度快。缺点是可执行代码体积大。</p>
<pre class="code literal-block"><span></span><span class="cp">#define min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))</span>
</pre>


<p><code>y = min(1, 2);</code>会被扩展成<code>y = ((1) &lt; (2) ? (1) : (2));</code></p>
<hr>
<h3>宏特殊用法</h3>
<h4>1. 字符串化(Stringification)</h4>
<p>在宏体中，如果宏参数前加个<code>#</code>，那么在宏体扩展的时候，宏参数会被扩展成字符串的形式。如：</p>
<pre class="code literal-block"><span></span><span class="cp">#define WARN_IF(EXP) \</span>
<span class="cp">     do { if (EXP) \</span>
<span class="cp">             fprintf (stderr, "Warning: " #EXP "\n"); } \</span>
<span class="cp">     while (0)</span>
</pre>


<p><code>WARN_IF (x == 0);</code>会被扩展成：</p>
<pre class="code literal-block"><span></span><span class="k">do</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Warning: "</span> <span class="s">"x == 0"</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre>


<p>这种用法可以用在assert中，如果断言失败，可以将失败的语句输出到反馈信息中</p>
<h4>2. 连接(Concatenation)</h4>
<p>在宏体中，如果宏体所在标示符中有<code>##</code>，那么在宏体扩展的时候，宏参数会被直接替换到标示符中。如：</p>
<pre class="code literal-block"><span></span><span class="cp">#define COMMAND(NAME)  { #NAME, NAME ## _command }</span>

<span class="k">struct</span> <span class="n">command</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>
</pre>


<p>在宏扩展的时候</p>
<pre class="code literal-block"><span></span><span class="k">struct</span> <span class="n">command</span> <span class="n">commands</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="n">COMMAND</span> <span class="p">(</span><span class="n">quit</span><span class="p">),</span>
    <span class="n">COMMAND</span> <span class="p">(</span><span class="n">help</span><span class="p">),</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre>


<p>会被扩展成：</p>
<pre class="code literal-block"><span></span><span class="k">struct</span> <span class="n">command</span> <span class="n">commands</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span> <span class="s">"quit"</span><span class="p">,</span> <span class="n">quit_command</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s">"help"</span><span class="p">,</span> <span class="n">help_command</span> <span class="p">},</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre>


<p>这样就节省了大量时间，提高效率。</p>
<hr>
<h3>几个坑</h3>
<h4>1. 语法问题</h4>
<p>由于是纯文本替换，C预处理器不对宏体做任何语法检查，像缺个括号、少个分号神马的预处理器是不管的。这里要格外小心，由此可能引出各种奇葩的问题，一下还很难找到根源。</p>
<h4>2. 算符优先级问题</h4>
<p>不仅宏体是纯文本替换，宏参数也是纯文本替换。有以下一段简单的宏，实现乘法：</p>
<pre class="code literal-block"><span></span><span class="cp">#define MULTIPLY(x, y) x * y</span>
</pre>


<p><code>MULTIPLY(1, 2)</code>没问题，会正常展开成<code>1 * 2</code>。有问题的是这种表达式<code>MULTIPLY(1+2, 3)</code>，展开后成了<code>1+2 * 3</code>，显然优先级错了。</p>
<p>在宏体中，给引用的参数加个括号就能避免这问题。</p>
<pre class="code literal-block"><span></span><span class="cp">#define MULTIPLY(x, y) (x) * (y)</span>
</pre>


<p><code>MULTIPLY(1+2, 3)</code>就会被展开成<code>(1+2) * (3)</code>，优先级正常了。</p>
<p>其实这个问题和下面要说到的某些问题都属于由于纯文本替换而导致的语义破坏问题，要格外小心。</p>
<h4>3. 分号吞噬问题</h4>
<p>有如下宏定义：</p>
<pre class="code literal-block"><span></span><span class="cp">#define SKIP_SPACES(p, limit)  \</span>
<span class="cp">     { char *lim = (limit);         \</span>
<span class="cp">       while (p &lt; lim) {            \</span>
<span class="cp">         if (*p++ != ' ') {         \</span>
<span class="cp">           p--; break; }}}</span>
</pre>


<p>假设有如下一段代码：</p>
<pre class="code literal-block"><span></span><span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
   <span class="n">SKIP_SPACES</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">lim</span><span class="p">);</span>
<span class="k">else</span> <span class="p">...</span>
</pre>


<p>一编译，GCC报<code>error: ‘else’ without a previous ‘if’</code>。原来这个看似是一个函数的宏被展开后是一段大括号括起来的代码块，加上分号之后这个if逻辑块就结束了，所以编译器发现这个else没有对应的if。</p>
<p>这个问题一般用<code>do ... while(0)</code>的形式来解决：</p>
<pre class="code literal-block"><span></span><span class="cp">#define SKIP_SPACES(p, limit)     \</span>
<span class="cp">     do { char *lim = (limit);         \</span>
<span class="cp">          while (p &lt; lim) {            \</span>
<span class="cp">            if (*p++ != ' ') {         \</span>
<span class="cp">              p--; break; }}}          \</span>
<span class="cp">     while (0)</span>
</pre>


<p>展开后就成了</p>
<pre class="code literal-block"><span></span><span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">do</span> <span class="p">...</span> <span class="k">while</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">else</span> <span class="p">...</span>
</pre>


<p>这样就消除了分号吞噬问题。</p>
<p>这个技巧在Linux内核源码里很常见，比如这个置位宏<code>#define SET_REG_BIT(reg, bit)              do { (reg |= (1 &lt;&lt; (bit))); } while (0)</code>(位于arch/mips/include/asm/mach-pnx833x/gpio.h)</p>
<h4>4. 宏参数重复调用</h4>
<p>有如下宏定义：</p>
<pre class="code literal-block"><span></span><span class="cp">#define min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))</span>
</pre>


<p>当有如下调用时<code>next = min (x + y, foo (z));</code>，宏体被展开成<code>next = ((x + y) &lt; (foo (z)) ? (x + y) : (foo (z)));</code>，可以看到，<code>foo(z)</code>被重复调用了两次，做了重复计算。更严重的是，如果foo是不可重入的(foo内修改了全局或静态变量)，程序会产生逻辑错误。</p>
<p>所以，尽量不要在宏参数中传入函数调用。</p>
<h4>5. 对自身的递归引用</h4>
<p>有如下宏定义：</p>
<pre class="code literal-block"><span></span><span class="cp">#define foo (4 + foo)</span>
</pre>


<p>按前面的理解，<code>(4 + foo)</code>会展开成<code>(4 + (4 + foo))</code>，然后一直展开下去，直至内存耗尽。但是，预处理器采取的策略是<strong><em>只展开一次</em></strong>。也就是说，<code>foo</code>只会展开成<code>(4 + foo)</code>，而展开之后<code>foo</code>的含义就要根据上下文来确定了。</p>
<p>对于以下的交叉引用，宏体也只会展开一次。</p>
<pre class="code literal-block"><span></span><span class="cp">#define x (4 + y)</span>
<span class="cp">#define y (2 * x)</span>
</pre>


<p><code>x</code>展开成<code>(4 + y) -&gt; (4 + (2 * x))</code>，<code>y</code>展开成<code>(2 * x) -&gt; (2 * (4 + y))</code>。</p>
<p><strong>注意，这是极不推荐的写法，程序可读性极差。</strong></p>
<h4>6. 宏参数预处理</h4>
<p>宏参数中若包含另外的宏，那么宏参数在被代入到宏体之前会做一次完全的展开，除非宏体中含有<code>#</code>或<code>##</code>。</p>
<p>有如下宏定义：</p>
<pre class="code literal-block"><span></span><span class="cp">#define AFTERX(x) X_ ## x</span>
<span class="cp">#define XAFTERX(x) AFTERX(x)</span>
<span class="cp">#define TABLESIZE 1024</span>
<span class="cp">#define BUFSIZE TABLESIZE</span>
</pre>


<ul>
<li>
<code>AFTERX(BUFSIZE)</code>会被展开成<code>X_BUFSIZE</code>。因为宏体中含有<code>##</code>，宏参数直接代入宏体。</li>
<li>
<code>XAFTERX(BUFSIZE)</code>会被展开成<code>X_1024</code>。因为<code>XAFTERX(x)</code>的宏体是<code>AFTERX(x)</code>，并没有<code>#</code>或<code>##</code>，所以<code>BUFSIZE</code>在代入前会被完全展开成<code>1024</code>，然后才代入宏体，变成<code>X_1024</code>。</li>
</ul>
<p>-EOF-</p>
<hr>
<p>参考资料：</p>
<p><a href="http://gcc.gnu.org/onlinedocs/cpp/Macros.html">http://gcc.gnu.org/onlinedocs/cpp/Macros.html</a></p>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/python-descriptor.html" class="u-url">Python descriptor</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/python-descriptor.html" rel="bookmark"><time class="published dt-published" datetime="2013-06-12T12:31:54+08:00" title="2013-06-12 12:31">2013-06-12 12:31</time></a></p>
                <p class="commentline">
        
    <a href="posts/python-descriptor.html#disqus_thread" data-disqus-identifier="cache/posts/python-descriptor.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>一次偶然发现，Python的对象竟然可以在运行期动态添加类定义时没有的属性，这又颠覆了我对Python OO机制的理解。Google了一把，顺着<code>__dict__</code>属性一路找到descriptor，揭开了隐藏在Python对象之后的内幕。</p>
<p>本文主要记录Python的descriptor机制，以及其在Python对象的属性、方法绑定上的作用。</p>
<p>先从本文的始作俑者，运行期动态添加对象属性开始讲起。</p>
<pre class="code literal-block"><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s">'value'</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'function f'</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>
</pre>


<p>以上代码奇迹般的没有报错，而且还输出了1。这肯定会让写过C++/Java代码的童鞋表示吃惊，Python变量类型动态也就不稀奇了，对象属性还能动态添加的？Python到底在背后做了什么？</p>
<h3>神奇的__dict__</h3>
<p>在<code>a.attr = 1</code>前后分别加上一行<code>print(a.__dict__)</code>就会得到如下结果:  </p>
<pre class="code literal-block"><span class="p">{</span><span class="s">'value'</span><span class="p">:</span> <span class="s">'value'</span><span class="p">}</span>  
<span class="mi">1</span>  
<span class="p">{</span><span class="s">'value'</span><span class="p">:</span> <span class="s">'value'</span><span class="p">,</span> <span class="s">'attr'</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span> 
</pre>


<p>显而易见，我们在运行期定义的属性和类定义时定义的属性都被放在了<code>__dict__</code>里。</p>
<p>到这里有人可能就有疑问了，Python里的一切不都是对象麽？为什么成员函数<code>__init__</code>、<code>f</code>不在这个字典里？</p>
<p>看看<code>A.__dict__</code>里有什么就明白了：  </p>
<pre class="code literal-block"><span class="p">{</span><span class="s">'__dict__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">attribute</span> <span class="s">'__dict__'</span> <span class="n">of</span> <span class="s">'A'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="s">'__doc__'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
 <span class="s">'__init__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">__main__</span><span class="o">.</span><span class="n">__init__</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="s">'__module__'</span><span class="p">:</span> <span class="s">'__main__'</span><span class="p">,</span>
 <span class="s">'__weakref__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">attribute</span> <span class="s">'__weakref__'</span> <span class="n">of</span> <span class="s">'A'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="s">'f'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">__main__</span><span class="o">.</span><span class="n">f</span><span class="o">&gt;</span><span class="p">}</span>
</pre>


<p>这时才恍然大悟，如果成员变量看做是对象的属性，那么成员函数就应该看成是类的属性，被全部对象共享嘛。</p>
<p>更精确地讲，以<code>object.attribute</code>访问一个对象的属性时，属性的搜索顺序为：</p>
<ol>
<li>对象自身，<code>object.__dict__</code>
</li>
<li>对象类型，<code>object.__class__.__dict__</code>
</li>
<li>对象类型的基类，<code>object.__class__.__bases__</code>中的所有<code>__dict__</code>。注意，当多重继承的情况下有菱形继承的时候，Python会根据MRO确定的顺序进行搜索。关于MRO(Method Resolution Order)是什么有时间专门写一篇文章总结一下。</li>
</ol>
<p>当以上三个步骤都没有找到要访问的属性的时候Python就只能抛出<code>AttributeError</code>异常了。</p>
<h3>Descriptor是什么</h3>
<p>讲了这么多，貌似跟descriptor半毛钱关系没有嘛。别急，接着往下看。</p>
<pre class="code literal-block"><span class="k">class</span> <span class="nc">RevealAccess</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initval</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">'var'</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">initval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">'Retrieving'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">'Updating'</span> <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
</pre>


<p>来测试一下这个类</p>
<pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">RevealAccess</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">'var "x"'</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">x</span>
<span class="n">Retrieving</span> <span class="n">var</span> <span class="s">"x"</span>
<span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">Updating</span> <span class="n">var</span> <span class="s">"x"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">x</span>
<span class="n">Retrieving</span> <span class="n">var</span> <span class="s">"x"</span>
<span class="mi">20</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">y</span>
<span class="mi">5</span>
</pre>


<p>这个<code>RevealAccess</code>的对象就是一个descriptor，其作用就是在存取变量的时候做了一个hook。访问属性<code>m.x</code>就是调用<code>__get__</code>方法，设置属性值就是调用<code>__set__</code>方法。还可以有一个<code>__delete__</code>方法，在<code>del m.x</code>时被调用。</p>
<p>只要一个类定义了以上三种方法，其对象就是一个descriptor。我们把同时定义<code>__get__</code>和<code>__set__</code>方法的descriptor叫做<strong>data descriptor</strong>，把只定义<code>__get__</code>方法的叫<strong>non-data descriptor</strong></p>
<h3>Method binding</h3>
<p>有了以上两个概念，我们就能讨论Python的方法绑定了。</p>
<p>还记得讨论<code>__dict__</code>时的成员函数<code>f</code>吗？按照我们的推测，<code>A.__dict__['f']</code>应该和<code>a.f</code>是一个东西。但是！！！</p>
<pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">'f'</span><span class="p">]</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">__main__</span><span class="o">.</span><span class="n">f</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">f</span>
<span class="o">&lt;</span><span class="n">bound</span> <span class="n">method</span> <span class="n">A</span><span class="o">.</span><span class="n">f</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">A</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f9d69cc5950</span><span class="o">&gt;&gt;</span>
</pre>


<p>这两个显然不是一个东西，一个是<code>function</code>，一个是<code>bound method</code>。这是什么情况？淡定，看下面</p>
<pre class="code literal-block"><span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">'f'</span><span class="p">]</span><span class="o">.</span><span class="n">__get__</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">bound</span> <span class="n">method</span> <span class="n">A</span><span class="o">.</span><span class="n">f</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">A</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f9d69cc5950</span><span class="o">&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">f</span>
<span class="o">&lt;</span><span class="n">bound</span> <span class="n">method</span> <span class="n">A</span><span class="o">.</span><span class="n">f</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">A</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f9d69cc5950</span><span class="o">&gt;&gt;</span>
</pre>


<p>这下放心了吧:D</p>
<p>其实，类的成员函数就是一个descriptor，在实例化对象a的时候，Python就做了这么一个过程(伪码，详见Objects/funcobject.c)：<code>a.f = A.__dict__['f'].__get__(a, A)</code></p>
<p>纯Python模拟的函数对象就像这样：</p>
<pre class="code literal-block"><span class="k">class</span> <span class="nc">Function</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">.</span> <span class="o">.</span> <span class="o">.</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="s">"Simulate func_descr_get() in Objects/funcobject.c"</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="p">)</span>
</pre>


<p>然后就好理解<code>staticmethod</code>和<code>classmethod</code>这两个decorator了吧。<code>staticmethod</code>无视了传入的第一个self参数，<code>classmethod</code>手工加了一个类对象参数进去。它们的纯Python模拟就像下面所示：</p>
<pre class="code literal-block"><span class="k">class</span> <span class="nc">StaticMethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
 <span class="s">"Emulate PyStaticMethod_Type() in Objects/funcobject.c"</span>

 <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>

 <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span>

<span class="k">class</span> <span class="nc">ClassMethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
     <span class="s">"Emulate PyClassMethod_Type() in Objects/funcobject.c"</span>

     <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>

     <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">klass</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
               <span class="n">klass</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
          <span class="k">def</span> <span class="nf">newfunc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
               <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">newfunc</span>
</pre>


<hr>
<p>研究Python的底层实现是个很有意思的事，至少能让我在使用Python时更加放心：）</p>
<p>全文完</p>
<hr>
<p>参考资料：</p>
<ol>
<li>How-To Guide for Descriptors: <a href="http://users.rcn.com/python/download/Descriptor.htm">http://users.rcn.com/python/download/Descriptor.htm</a>
</li>
<li>Python Attributes and Methods: <a href="http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html">http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html</a>
</li>
<li>《Expert Python Programming》,Tarek Ziadé: <a href="http://book.douban.com/subject/3285148/">http://book.douban.com/subject/3285148/</a>
</li>
</ol>
</div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="index-1.html" rel="next">Older posts</a>
            </li>
        </ul></nav><script>var disqus_shortname="hbprotoss";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
            <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
                    <div class="sidebar-module sidebar-module-inset">
      <h4>About</h4>
      <p>踏歌长行</p>
      <p>梦想永在</p>
    </div>
    <div class="sidebar-module">
      <h4>Links</h4>
      <ol class="list-unstyled">
<li><a href="http://weibo.com/hbprotoss">Weibo</a></li>
        <li><a href="https://twitter.com/hbprotoss">Twitter</a></li>
        <li><a href="https://github.com/hbprotoss">GitHub</a></li>
      </ol>
<h4>友情链接</h4>
      <ol class="list-unstyled">
<li><a href="http://mckobe23.github.io">喀秋莎的技术博客</a></li>
      </ol>
</div>
    
            </div>
        <!--End of body content-->
        </div>
    </div>
</div>

<footer class="blog-footer" id="footer"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png"></a><br>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。
<br>Contents © 2016 <a href="mailto:">hbprotoss</a> - Powered by <a href="http://nikola.ralsina.com.ar">Nikola</a>
    
</footer><script src="assets/js/all-nocdn.js"></script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
