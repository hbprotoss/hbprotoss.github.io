<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>hbprotoss的博客 | hbprotoss的博客</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="http://hbprotoss.github.io/index.html">
<link rel="next" href="index-1.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]--><link rel="prefetch" href="posts/classpath-vs-classpath-in-spring.html" type="text/html">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<div class="blog-masthead">
    <div class="container">
<!-- This keeps the margins nice -->
        <nav class="blog-nav" role="navigation"><a href="#" class="blog-nav-item active">Home <span class="sr-only">(active)</span></a>
            <a href="archive.html" class="blog-nav-item">Archives</a>
            <a href="categories/index.html" class="blog-nav-item">Tags</a>
            <a href="rss.xml" class="blog-nav-item">RSS</a>

            

                
                
                    
                
            
        </nav>
</div>
<!-- /.container -->
</div>
<!-- End of Menubar -->

<div class="container" id="content" role="main">
    <div class="body-content">
        <div class="blog-header">
            <h1 class="blog-title">
                <a href="http://hbprotoss.github.io/">

                    <span id="blog-title">hbprotoss的博客</span>
                </a>
            </h1>
            <p class="lead blog-description"></p>
            
        </div>
        <!--Body content-->
        <div class="row">
            <div class="col-sm-8 blog-main">
                

<div class="postindex">
    <article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/classpath-vs-classpath-in-spring.html" class="u-url">classpath* vs classpath in spring</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/classpath-vs-classpath-in-spring.html" rel="bookmark"><time class="published dt-published" datetime="2016-07-06T09:12:52+08:00" title="2016-07-06 09:12">2016-07-06 09:12</time></a></p>
                <p class="commentline">
        
    <a href="posts/classpath-vs-classpath-in-spring.html#disqus_thread" data-disqus-identifier="cache/posts/classpath-vs-classpath-in-spring.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>记录一下spring里读取资源时的classpath*和classpath表达式的区别。不想看细节的可以直接跳到最后直接看结论。</p>
<p>读取资源的主要逻辑在<code>PathMatchingResourcePatternResolver.getResources</code></p>
<pre class="code literal-block"><span></span><span class="kd">public</span> <span class="n">Resource</span><span class="o">[]</span> <span class="nf">getResources</span><span class="o">(</span><span class="n">String</span> <span class="n">locationPattern</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">locationPattern</span><span class="o">,</span> <span class="s">"Location pattern must not be null"</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">locationPattern</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="n">CLASSPATH_ALL_URL_PREFIX</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// a class path resource (multiple resources for same name possible)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">getPathMatcher</span><span class="o">().</span><span class="na">isPattern</span><span class="o">(</span><span class="n">locationPattern</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">CLASSPATH_ALL_URL_PREFIX</span><span class="o">.</span><span class="na">length</span><span class="o">())))</span> <span class="o">{</span>
            <span class="c1">// a class path resource pattern</span>
            <span class="k">return</span> <span class="n">findPathMatchingResources</span><span class="o">(</span><span class="n">locationPattern</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// all class path resources with the given name</span>
            <span class="k">return</span> <span class="n">findAllClassPathResources</span><span class="o">(</span><span class="n">locationPattern</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">CLASSPATH_ALL_URL_PREFIX</span><span class="o">.</span><span class="na">length</span><span class="o">()));</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// Only look for a pattern after a prefix here</span>
        <span class="c1">// (to not get fooled by a pattern symbol in a strange prefix).</span>
        <span class="kt">int</span> <span class="n">prefixEnd</span> <span class="o">=</span> <span class="n">locationPattern</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="s">":"</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">getPathMatcher</span><span class="o">().</span><span class="na">isPattern</span><span class="o">(</span><span class="n">locationPattern</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">prefixEnd</span><span class="o">)))</span> <span class="o">{</span>
            <span class="c1">// a file pattern</span>
            <span class="k">return</span> <span class="n">findPathMatchingResources</span><span class="o">(</span><span class="n">locationPattern</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// a single resource with the given name</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">Resource</span><span class="o">[]</span> <span class="o">{</span><span class="n">getResourceLoader</span><span class="o">().</span><span class="na">getResource</span><span class="o">(</span><span class="n">locationPattern</span><span class="o">)};</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre>


<ul>
<li>
<p>classpath*:resource</p>
<p>代码中的if逻辑，通过findAllClassPathResources，遍历整个classpath，从搜索所有名字匹配的文件返回</p>
</li>
<li>
<p>classpath:resource</p>
<p>代码中的else逻辑，<code>getResourceLoader().getResource(locationPattern)</code>最终调用tomcat提供的WebappClassLoader，从classpath中遍历每个目录（包括jar），寻找指定的resource直到找到指定的第一个匹配文件返回</p>
</li>
</ul>
<p>读取完resource列表之后，AbstractBeanDefinitionReader.loadBeanDefinitions会载入得到resource列表</p>
<pre class="code literal-block"><span></span><span class="n">Resource</span><span class="o">[]</span> <span class="n">resources</span> <span class="o">=</span> <span class="o">((</span><span class="n">ResourcePatternResolver</span><span class="o">)</span> <span class="n">resourceLoader</span><span class="o">).</span><span class="na">getResources</span><span class="o">(</span><span class="n">location</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">loadCount</span> <span class="o">=</span> <span class="n">loadBeanDefinitions</span><span class="o">(</span><span class="n">resources</span><span class="o">);</span>
</pre>


<h4>结论</h4>
<p>从<code>classpath*:resource</code>中读取资源，就相当于把整个classpath下能找到的同名resource按照classpath中的次序拼接成一个大文件后载入，位于classpath后部的resource定义会覆盖前面的。由于tomcat会保证<code>WEB-INF/class</code>下的class会放在classpath中的第一位，所以导致jar中的同名resource定义覆盖app中的定义。</p>
<p><code>classpath:resource</code>仅载入classpath路径中碰到的第一个resource。</p>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/cookiekeng-yi-ji.html" class="u-url">Cookie坑一记</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/cookiekeng-yi-ji.html" rel="bookmark"><time class="published dt-published" datetime="2016-07-04T15:23:48+08:00" title="2016-07-04 15:23">2016-07-04 15:23</time></a></p>
                <p class="commentline">
        
    <a href="posts/cookiekeng-yi-ji.html#disqus_thread" data-disqus-identifier="cache/posts/cookiekeng-yi-ji.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>关于Cookie的domain属性，<a href="https://tools.ietf.org/html/rfc6265#section-4.1.2.3">RFC6265</a>上是这么说的：</p>
<ol>
<li>如果domain属性缺失，那么该cookie只能对<strong>当前host</strong>可见。比如，xx.com下有个cookie，<code>Set-Cookie</code>头没有带domain属性，那么这个cookie只对xx.com下的页面可见，a.xx.com等子域名不可见</li>
<li>.xx.com这种domain其实是不合法的，只不过浏览器在见到这种域名的时候，需要自动把最前面的.忽略掉，把xx.com作为cookie的domain，即xx.com及其子域名都可见</li>
</ol>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/thymeleafde-keng-yi-ji.html" class="u-url">thymeleaf的坑一记</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/thymeleafde-keng-yi-ji.html" rel="bookmark"><time class="published dt-published" datetime="2016-05-31T08:37:04+08:00" title="2016-05-31 08:37">2016-05-31 08:37</time></a></p>
                <p class="commentline">
        
    <a href="posts/thymeleafde-keng-yi-ji.html#disqus_thread" data-disqus-identifier="cache/posts/thymeleafde-keng-yi-ji.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>记录下thymeleaf 3.0新增的<code>th:field</code>与<code>th:each</code>中生成的变量结合使用时的坑。</p>
<p>代码就是官方例子<a href="https://github.com/thymeleaf/thymeleafexamples-stsm.git">https://github.com/thymeleaf/thymeleafexamples-stsm.git</a>，在<code>webapp/WEB-INF/seedstartermng.html</code>中118-131行</p>
<pre class="code literal-block"><span></span><span class="p">&lt;</span><span class="nt">tr</span> <span class="na">th:each</span><span class="o">=</span><span class="s">"row,rowStat : *{rows}"</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span> <span class="na">th:text</span><span class="o">=</span><span class="s">"${rowStat.count}"</span><span class="p">&gt;</span>1<span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">select</span> <span class="na">th:field</span><span class="o">=</span><span class="s">"*{rows[__${rowStat.index}__].variety}"</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">option</span> <span class="na">th:each</span><span class="o">=</span><span class="s">"var : ${allVarieties}"</span> <span class="na">th:value</span><span class="o">=</span><span class="s">"${var.id}"</span> <span class="na">th:text</span><span class="o">=</span><span class="s">"${var.name}"</span><span class="p">&gt;</span>Thymus Thymi<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">select</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">th:field</span><span class="o">=</span><span class="s">"*{rows[__${rowStat.index}__].seedsPerCell}"</span> <span class="na">th:errorclass</span><span class="o">=</span><span class="s">"fieldError"</span> <span class="p">/&gt;</span>
  <span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">button</span> <span class="na">type</span><span class="o">=</span><span class="s">"submit"</span> <span class="na">name</span><span class="o">=</span><span class="s">"removeRow"</span> <span class="na">th:value</span><span class="o">=</span><span class="s">"${rowStat.index}"</span> <span class="na">th:text</span><span class="o">=</span><span class="s">"#{seedstarter.row.remove}"</span><span class="p">&gt;</span>Remove row<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">tr</span><span class="p">&gt;</span>
</pre>


<p>其中第二个td取出rows中的每一行的variety，做成一个select下拉菜单，当我尝试用<code>${row.variety}</code>替换原文的<code>*{rows[__${rowStat.index}__].variety}</code>时，页面渲染抛出异常<code>Neither BindingResult nor plain target object for bean name 'row' available as request attribute</code>。多方探索之后得出结论：这是我们使用的问题，设计时特意在遇到这种情况时为了避免服务端无法处理提交后的表单，就抛出异常。</p>
<p>用例子中的代码渲染完生成后的页面为：</p>
<pre class="code literal-block"><span></span><span class="p">&lt;</span><span class="nt">tr</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>1<span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">select</span> <span class="na">id</span><span class="o">=</span><span class="s">"rows0.variety"</span> <span class="na">name</span><span class="o">=</span><span class="s">"rows[0].variety"</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">"1"</span><span class="p">&gt;</span>Thymus vulgaris<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">"2"</span><span class="p">&gt;</span>Thymus x citriodorus<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">"3"</span><span class="p">&gt;</span>Thymus herba-barona<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">"4"</span><span class="p">&gt;</span>Thymus pseudolaginosus<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">option</span> <span class="na">value</span><span class="o">=</span><span class="s">"5"</span><span class="p">&gt;</span>Thymus serpyllum<span class="p">&lt;/</span><span class="nt">option</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">select</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">id</span><span class="o">=</span><span class="s">"rows0.seedsPerCell"</span> <span class="na">name</span><span class="o">=</span><span class="s">"rows[0].seedsPerCell"</span> <span class="na">value</span><span class="o">=</span><span class="s">""</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">button</span> <span class="na">type</span><span class="o">=</span><span class="s">"submit"</span> <span class="na">name</span><span class="o">=</span><span class="s">"removeRow"</span> <span class="na">value</span><span class="o">=</span><span class="s">"0"</span><span class="p">&gt;</span>Remove row<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">tr</span><span class="p">&gt;</span>
</pre>


<p>其中，<code>th:field</code>在渲染时会给目标元素加上id和name属性，name属性取<code>*{...}</code>中表达式的值。由于<code>__${rowStat.index}__</code>是个预处理语句，在渲染之前会直接文本替换，所以最终的表达式为<code>rows[0].variety</code>。</p>
<p>但是如果是<code>${row.variety}</code>，则最终name会被替换为<code>row.variety</code>，由于浏览器作为客户端无法知道服务端的逻辑，这样之后的每个tr中的元素都是这个表达式，表单提交的时候无法被spring解析成一个list对象，就会出现错误。</p>
<p>官方站在实现角度的解释可以看这个<a href="https://github.com/thymeleaf/thymeleaf/issues/505#issuecomment-222557959">issue</a></p>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/xpathbei-wang.html" class="u-url">XPath备忘</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/xpathbei-wang.html" rel="bookmark"><time class="published dt-published" datetime="2016-04-12T15:46:09+08:00" title="2016-04-12 15:46">2016-04-12 15:46</time></a></p>
                <p class="commentline">
        
    <a href="posts/xpathbei-wang.html#disqus_thread" data-disqus-identifier="cache/posts/xpathbei-wang.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>最近写了几个scrapy的爬虫程序，里面用到了xpath，写个日志记录一下用法。</p>
<h2>XPath是什么</h2>
<p>XPath是一种用于xml、html等结构化文档中寻址定位特定元素等描述性语言</p>
<h2>XPath主要功能</h2>
<p>下面以如下测试文档为例进行说明：</p>
<pre class="code literal-block"><span></span><span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">contents</span> <span class="na">id</span><span class="o">=</span><span class="s">"content"</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">para</span><span class="p">&gt;&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">"one.html"</span> <span class="na">class</span><span class="o">=</span><span class="s">"normal-link"</span><span class="p">&gt;</span>One<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;&lt;/</span><span class="nt">para</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">para</span><span class="p">&gt;&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">"two.html"</span> <span class="na">class</span><span class="o">=</span><span class="s">"normal-link"</span><span class="p">&gt;</span>Two<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;&lt;/</span><span class="nt">para</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">para</span><span class="p">&gt;&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">"three.html"</span> <span class="na">class</span><span class="o">=</span><span class="s">"ex-link"</span><span class="p">&gt;</span>Three<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;&lt;/</span><span class="nt">para</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">contents</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</pre>


<h3>精确路径寻址</h3>
<p>指通过精确制定的路径取得元素。例如</p>
<p>和unix文件系统概念一致，有如下几种定位方式：</p>
<ul>
<li>绝对路径，<code>/html/body/contents/para</code>能查找出文档中的三个para元素</li>
<li>相对路径，在<code>/html/body</code>路径下，<code>/contents/para</code>同样也能查找出这三个para元素</li>
<li>父级路径，<code>.</code>表示当前路径，<code>..</code>表示当前路径的父级路径</li>
</ul>
<h3>模糊路径寻址</h3>
<p>不需要指定绝对路径或根据当前路径确定的相对路径，只需要指定某个子结构，就能查找出所有符合这个子结构的元素。如</p>
<ul>
<li>
<code>//contents/para</code>在任何路径下，都能查找到<strong>整个文档</strong>下的这三个para元素</li>
<li>
<code>.//contents/para</code>能在当前路径下，查找到子节点中任何符合<code>contents/para</code>结构的元素</li>
</ul>
<h3>节点属性匹配</h3>
<p>格式：元素[@属性="xxx"]</p>
<ul>
<li>
<code>a[@class="normal-link"]</code>能查找出两个有带normal-link class的a链</li>
<li>
<code>para[a/@class="ex-link"]</code>能查找出一级子元素中有带ex-link class的a链的para元素，这里就是<code>&lt;para&gt;&lt;a href="three.html" class="ex-link"&gt;Three&lt;/a&gt;&lt;/para&gt;</code>
</li>
</ul>
<h3>属性选择</h3>
<p>查找某个元素中的特定属性值，如：<code>a[@class="ex-link"]/@href</code>能读取第三个a链的href值</p>
<h3>内置函数</h3>
<ul>
<li>node()，返回任意种类的节点。比如和内置关键字<code>child</code>组合成<code>/html/body/contents/child::node()</code>，可以选择所有的para节点</li>
<li>text()，返回节点中包含的文本。<code>/html/body/contents/para/a[@class="ex-link"]/text()</code>返回Three。特别的，和模糊路径寻址配合，如<code>/html/body/contents//text()</code>，能返回contents下的<code>One Two Three</code>字符串</li>
</ul>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/da-jian-zhi-neng-fan-qiang-lu-you-qi.html" class="u-url">搭建智能翻墙路由器</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/da-jian-zhi-neng-fan-qiang-lu-you-qi.html" rel="bookmark"><time class="published dt-published" datetime="2015-04-16T08:49:13+08:00" title="2015-04-16 08:49">2015-04-16 08:49</time></a></p>
                <p class="commentline">
        
    <a href="posts/da-jian-zhi-neng-fan-qiang-lu-you-qi.html#disqus_thread" data-disqus-identifier="cache/posts/da-jian-zhi-neng-fan-qiang-lu-you-qi.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>本文着重介绍如何搭建智能翻墙路由器，实现避免DNS污染，并且自动根据是否是国内IP来决定是否翻墙，从而使任何连接路由器的设备无障碍穿墙出去。</p>
<p>思路是，用shadowsocks建立起翻墙代理服务，用shadowsocks的udp relay模式转发DNS请求，解决DNS污染，再配置iptables根据IP决定是否走shadowsocks来翻墙。</p>
<h2>准备材料</h2>
<ul>
<li>能刷OpenWrt的智能路由器。我用的是小米路由器MINI，16MB ROM，128MB DDR2内存，MT7620A处理器，运行毫无压力（真的不是广告。。。）</li>
<li>OpenWrt。这里选的是<a href="http://downloads.openwrt.org.cn/PandoraBox/">PandoraBox</a>版</li>
<li>shadowsocks client，PandoraBox自带</li>
<li>ChinaDNS，PandoraBox自带</li>
<li>VPS一台</li>
<li>shadowsocks server，选用C实现：shadowsocks-libev，go和Python版没有UDP relay功能，不能实现DNS请求转发</li>
</ul>
<h2>步骤</h2>
<h3>shadowsocks server</h3>
<p>shadowsocks-libev的安装参考<a href="http://shadowsocks.org/en/download/servers.html">http://shadowsocks.org/en/download/servers.html</a>中的“C with libev”一节</p>
<p>安装完成之后将如下配置写入config.json</p>
<pre class="code literal-block">{
    "server":"0.0.0.0",
    "server_port":8025,
    "password":"123456",
    "timeout":300,
    "method":"aes-256-cfb"
}
</pre>


<p>分别指定了服务器的binding address，端口，密码，超时时间和加密方式。按需更改</p>
<p>在远程VPS上启动shadowsocks server: <code>ss-server -c config.json -u</code></p>
<p>注意得加上<code>-u</code>选项，enable udprelay mode。用作DNS请求转发，避免DNS污染。</p>
<h3>shadowsocks client</h3>
<p>在本地路由器上起shadowsocks client</p>
<h4>ss-redir</h4>
<p>ss-redir用于将客户端的原始数据封装成shadowsocks协议内容，转发给server，实现透明转发。</p>
<p>在本地路由器启动ss-redir: <code>ss-redir -s "your_server_ip" -p "your_server_port" -l "local_service_port" -m "encryption_method" -k "server_password" -f "pid_file_path"</code>
注意这里不需要<code>-u</code>选项，转发的是TCP包，ss-redir也不支持这个选项。</p>
<h4>ss-tunnel</h4>
<p>ss-tunnel用于实现本地port forward，和ssh的port forward一样，只是加密方式用了shadowsocks协议，用于在本地起服务，转发DNS请求</p>
<p>在本地路由器启动ss-tunnel: <code>ss-tunnel -s "your_server_ip" -p "your_server_port" -l "local_service_port" -m "encryption_method" -k "server_password" -L "server_ip:server_port" -f "pid_file_path" -u</code></p>
<p>这个<code>-L</code>选项理论上可以填国外DNS的IP/PORT，比如<code>8.8.8.8:53</code>，我在我的VPS起了一个DNS转发服务，填了自己的IP/PORT，效果应该一样。<code>-u</code>是开启udp relay，DNS是UDP包嘛</p>
<h3>ChinaDNS</h3>
<p>如果所有DNS请求都走国外DNS server，国内有些网站（如微博）在海外有服务器，就会比较慢。ChinaDNS保证的就是国内域名能解析成国内IP，国外域名解析成国外IP。</p>
<p>在本地路由器启动ChinaDNS: <code>chinadns -l /etc/chinadns_iplist.txt -c /etc/chinadns_chnroute.txt -d -p "local_dns_port" -s 114.114.114.114,127.0.0.1:8026</code></p>
<p><code>-s</code>选项后加以逗号分隔的DNS服务器列表，最好国内、国外各有一个。由于前面通过ss-tunnel在本地起了一个端口转发到我的DNS服务，所以填的是<code>127.0.0.1:8026</code>。</p>
<p>ChinaDNS原理是，向所有列表中的DNS server发DNS请求，判断结果可信任条件是：国内DNS解析出的是国内IP，国外DNS解析出的是国外IP，<code>/etc/chinadns_chnroute.txt</code>里包含了国内IP网段，<code>/etc/chinadns_iplist.txt</code>里包含的是常见的被污染后的DNS解析结果IP。这样只要通过<code>dnsmasq</code>之类的把本地DNS请求转发到ChinaDNS的端口上，就能解决DNS污染的问题。</p>
<h3>iptables</h3>
<p>前面的准备工作完成之后，只要配置一下iptables，将国内TCP流量直接放行，国外TCP流量转发到ss-redir起的端口就行，判断依据是IP。</p>
<p>在nat表中新建一个SHADOWSOCKS链</p>
<pre class="code literal-block">iptables -t nat -N SHADOWSOCKS
</pre>


<p>远程VPS流量直接放行</p>
<pre class="code literal-block">iptables -t nat -A SHADOWSOCKS -d xxx.xxx.xx.xxx -j RETURN
</pre>


<p>内网流量直接放行</p>
<pre class="code literal-block">iptables -t nat -A SHADOWSOCKS -d 0.0.0.0/8 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 10.0.0.0/8 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 127.0.0.0/8 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 169.254.0.0/16 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 172.16.0.0/12 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 192.168.0.0/16 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 224.0.0.0/4 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 240.0.0.0/4 -j RETURN
</pre>


<p>国内IP流量直接放行(列表较长，这里不列举了，网上随便搜搜就有)</p>
<p>剩下的TCP流量转发到ss-redir端口</p>
<pre class="code literal-block">iptables -t nat -A SHADOWSOCKS -p tcp -j REDIRECT --to-ports xxx
</pre>


<h2>完工</h2>
<p>搞定之后，任何连接这个路由器的设备都能实现透明翻墙了。</p>
<p>以上</p>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/guan-yu-pythonyi-chang-chu-li-liu-cheng.html" class="u-url">关于Python异常处理流程</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/guan-yu-pythonyi-chang-chu-li-liu-cheng.html" rel="bookmark"><time class="published dt-published" datetime="2014-10-23T12:27:56+08:00" title="2014-10-23 12:27">2014-10-23 12:27</time></a></p>
                <p class="commentline">
        
    <a href="posts/guan-yu-pythonyi-chang-chu-li-liu-cheng.html#disqus_thread" data-disqus-identifier="cache/posts/guan-yu-pythonyi-chang-chu-li-liu-cheng.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<pre class="code literal-block"><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">'try'</span>
        <span class="k">raise</span> <span class="ne">NameError</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">'except'</span>
        <span class="k">raise</span> <span class="ne">KeyError</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">'else'</span>
        <span class="k">raise</span> <span class="ne">IOError</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">'finally'</span>
        <span class="k">raise</span> <span class="ne">ValueError</span>
</pre>


<p>在以上代码中，无论try里有没有异常，走得是except还是else，最终抛出的都是finally中的ValueError。为此小记一下Python里的异常处理流程。</p>
<p>Python当前状态的异常信息存储在线程状态PyThreadState中，包括type, value, traceback。无论是主动raise还是bug触发，异常信息最终都会通过PyErr_Restore(Python/errors.c)被修改。</p>
<p>异常处理的主要流程在PyEval_EvalFrameEx(Python/ceval.c)里，也是Python虚拟机的核心处理流程。</p>
<p>先说明几个概念以便理解：</p>
<ol>
<li>Python虚拟机里PyEval_EvalFrameEx干的活就是物理机里CPU干的活，根据指令作出相应动作</li>
<li>frame：一个函数的执行环境，可以理解为物理机上EBP, ESP等寄存器确定的函数调用栈，外加一点别的状态信息</li>
<li>blockstack：也是一个栈，隶属于一个frame。每当遇到循环或者try异常处理块都会压入一个block对象，块流程完了弹出</li>
<li>traceback：一个链表，记录发生异常时候的调用栈信息</li>
</ol>
<pre class="code literal-block"><span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyEval_EvalFrameEx</span><span class="p">(</span><span class="n">PyFrameObject</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">throwflag</span><span class="p">)</span>
<span class="p">{</span>

     <span class="k">register</span> <span class="k">enum</span> <span class="n">why_code</span> <span class="n">why</span><span class="p">;</span> <span class="c1">// 每一条指令处理完之后的状态，用来标记是否有异常</span>

     <span class="k">switch</span><span class="p">(</span><span class="n">opcode</span><span class="p">){}</span> <span class="c1">// 一个处理字节码指令的巨大switch</span>
     <span class="p">...</span>

     <span class="c1">// 记录traceback，用来在异常最终没有处理时打印调用栈信息</span>
     <span class="c1">// 这个why ==WHY_EXCEPTION条件很重要，如果在finally中发生异常，则why的值是WHY_RERAISE，因此不会进入这个条件记录新的traceback，而是直接覆盖当前的traceback，所以在最终的调用栈里，finally异常之前try/except/else中的异常信息也就被覆盖了</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">why</span> <span class="o">==</span> <span class="n">WHY_EXCEPTION</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PyTraceBack_Here</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">c_tracefunc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="n">call_exc_trace</span><span class="p">(</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">c_tracefunc</span><span class="p">,</span>
                               <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">c_traceobj</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
        <span class="p">}</span>

     <span class="c1">// 这种是finally中有异常的状态，reraise</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">why</span> <span class="o">==</span> <span class="n">WHY_RERAISE</span><span class="p">)</span>
            <span class="n">why</span> <span class="o">=</span> <span class="n">WHY_EXCEPTION</span><span class="p">;</span>

     <span class="c1">// 栈帧展开，主要为了在当前frame，沿着block栈向上寻找有没有try/except来接住异常</span>

<span class="nl">fast_block_end</span><span class="p">:</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">why</span> <span class="o">!=</span> <span class="n">WHY_NOT</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_iblock</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* Peek at the current block. */</span>
            <span class="n">PyTryBlock</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_blockstack</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_iblock</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

           <span class="p">......</span>

            <span class="cm">/* Now we have to pop the block. */</span>
            <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_iblock</span><span class="o">--</span><span class="p">;</span>

           <span class="p">......</span>

          <span class="c1">// 在finally块中</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">b_type</span> <span class="o">==</span> <span class="n">SETUP_FINALLY</span> <span class="o">||</span>
                <span class="p">......</span>
                <span class="p">)</span> <span class="p">{</span>

               <span class="c1">// 有异常(raise xxxError或bug触发的情况)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">why</span> <span class="o">==</span> <span class="n">WHY_EXCEPTION</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">PyObject</span> <span class="o">*</span><span class="n">exc</span><span class="p">,</span> <span class="o">*</span><span class="n">val</span><span class="p">,</span> <span class="o">*</span><span class="n">tb</span><span class="p">;</span>

                    <span class="c1">// 取出异常信息，压入执行栈</span>
                    <span class="n">PyErr_Fetch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tb</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">tb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">Py_None</span><span class="p">);</span>
                        <span class="n">PUSH</span><span class="p">(</span><span class="n">Py_None</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span>
                        <span class="n">PUSH</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
                    <span class="n">PUSH</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
                    <span class="n">PUSH</span><span class="p">(</span><span class="n">exc</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">// return或者continue语句</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">why</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">WHY_RETURN</span> <span class="o">|</span> <span class="n">WHY_CONTINUE</span><span class="p">))</span>
                        <span class="n">PUSH</span><span class="p">(</span><span class="n">retval</span><span class="p">);</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">PyInt_FromLong</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">why</span><span class="p">);</span>
                    <span class="n">PUSH</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
                <span class="p">}</span>
               <span class="c1">// 跳转到END_FINALLY指令进行扫尾工作</span>
                <span class="n">why</span> <span class="o">=</span> <span class="n">WHY_NOT</span><span class="p">;</span>
                <span class="n">JUMPTO</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">b_handler</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="cm">/* unwind stack */</span>

     <span class="c1">// 函数返回值为null说明函数中发生异常未处理</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">why</span> <span class="o">!=</span> <span class="n">WHY_RETURN</span><span class="p">)</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

     <span class="c1">// 栈帧回退，取回上一层函数执行信息</span>

    <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">frame</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_back</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>补充一点：</p>
<p>dis模块可以“反汇编”Python字节码变成“Python汇编语言”，下面就是示例代码的反汇编结果：</p>
<pre class="code literal-block">  6           0 SETUP_FINALLY           63 (to 66)
              3 SETUP_EXCEPT            15 (to 21)

  7           6 LOAD_CONST               1 ('try')
              9 PRINT_ITEM
             10 PRINT_NEWLINE

  8          11 LOAD_GLOBAL              0 (NameError)
             14 RAISE_VARARGS            1
             17 POP_BLOCK
             18 JUMP_FORWARD            30 (to 51)

  9     &gt;&gt;   21 DUP_TOP
             22 LOAD_GLOBAL              1 (Exception)
             25 COMPARE_OP              10 (exception match)
             28 POP_JUMP_IF_FALSE       50
             31 POP_TOP
             32 STORE_FAST               0 (e)
             35 POP_TOP

 10          36 LOAD_CONST               2 ('except')
             39 PRINT_ITEM
             40 PRINT_NEWLINE

 11          41 LOAD_GLOBAL              2 (KeyError)
             44 RAISE_VARARGS            1
             47 JUMP_FORWARD            12 (to 62)
        &gt;&gt;   50 END_FINALLY

 13     &gt;&gt;   51 LOAD_CONST               3 ('else')
             54 PRINT_ITEM
             55 PRINT_NEWLINE

 14          56 LOAD_GLOBAL              3 (IOError)
             59 RAISE_VARARGS            1
        &gt;&gt;   62 POP_BLOCK
             63 LOAD_CONST               0 (None)

 16     &gt;&gt;   66 LOAD_CONST               4 ('finally')
             69 PRINT_ITEM
             70 PRINT_NEWLINE

 17          71 LOAD_GLOBAL              4 (ValueError)
             74 RAISE_VARARGS            1
             77 END_FINALLY
             78 LOAD_CONST               0 (None)
             81 RETURN_VALUE
</pre>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/innodbyin-qing-suo-yin-xue-xi-bi-ji.html" class="u-url">InnoDB引擎索引学习笔记</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/innodbyin-qing-suo-yin-xue-xi-bi-ji.html" rel="bookmark"><time class="published dt-published" datetime="2013-11-16T19:31:34+08:00" title="2013-11-16 19:31">2013-11-16 19:31</time></a></p>
                <p class="commentline">
        
    <a href="posts/innodbyin-qing-suo-yin-xue-xi-bi-ji.html#disqus_thread" data-disqus-identifier="cache/posts/innodbyin-qing-suo-yin-xue-xi-bi-ji.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>最近在研究学习MySQL，本文记录下索引相关（主要B-Tree索引）的特性。</p>
<hr>
<h3>索引是什么</h3>
<p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。</p>
<p>按所用的数据结构分，有B-Tree索引（B+ Tree）、哈希索引、R-Tree索引等。按数据块的顺序和索引节点的逻辑顺序是否一致可以分为聚集索引和非聚集索引。聚集索引由于物理块连续，在范围扫描的时候可以减少磁头寻道时间，因而比非聚集索引高效。</p>
<h3>InnoDB索引结构</h3>
<p>InnoDB引擎的索引主体结构是B+Tree（这种数据结构的描述可以参考CSDN博主v_JULY_v的<a href="http://blog.csdn.net/v_JULY_v/article/details/6530142">从B树、B+树、B*树谈到R 树</a>）。</p>
<p>其中，主键索引(Primary Index)是聚集索引，中间节点是用于查询的边界值，叶子节点就是数据节点，叶子节点之间通过指针形成双向链表。如图：</p>
<p><img alt="primary_index.jpg" src="galleries/InnoDB/primary_index.jpg" title=""></p>
<p>辅助索引(Secondary Index)同样为B-Tree索引，只是叶子节点不是数据节点，而是对主键的引用。</p>
<p><img alt="secondary_index.jpg" src="galleries/InnoDB/secondary_index.jpg" title=""></p>
<p>由于此特性，InnoDB引擎要求数据表必须有一个主键，如果没有主键，在数据表创建的时候会自动生成一个唯一非空索引替代。这个特性也决定了InnoDB表的主键最好是一个自增的ID序列，这样在后续插入的过程中不会造成数据块的唯一，提升性能。</p>
<p>当所建立的索引为多列索引的时候，例如KEY(a,b,c)，中间节点依旧以最左边的一列a进行索引，只是在叶子节点上保存的不仅仅是a，而是(a,b,c)多字段排序后的序列。</p>
<h3>性能实测</h3>
<p>下面结合实际例子阐述现象和内部结构的关系</p>
<p>首先建立一个测试表：</p>
<pre class="code literal-block"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">test</span> <span class="p">(</span>
     <span class="n">id</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
     <span class="n">a</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
     <span class="n">b</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
     <span class="k">c</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
     <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
     <span class="k">KEY</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="k">c</span><span class="p">)</span>
<span class="p">)</span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>
</pre>


<p>数据项为(a,b,c)在0~200之间的所有组合项，共计8000000行记录。为了消除几次实验中以query cache为代表的各种server cache对实验数据的影响，每次实验后均重启mysql服务。</p>
<h4>索引对查询效率的影响</h4>
<p>首先是建立KEY(a,b,c)索引前后的性能对比，能很明显地看到索引大幅提升查询速度。没有索引的时候需要做全表扫描，建立索引之后通过B-Tree搜索。</p>
<pre class="code literal-block">没有索引（除主键，下同）
[SQL]select * from test where a = 0 and b = 1;
Affected rows: 0
Time: 0.324s

建立KEY(a,b,c)
[SQL]select * from test where a = 0 and b = 1;
Affected rows: 0
Time: 0.004s
</pre>


<p>由于MySQL优化器的优化，where条件中的各个子条件顺序对索引的使用没有影响。</p>
<pre class="code literal-block">[SQL]select * from test where b = 1 and a = 0;
Affected rows: 0
Time: 0.002s
</pre>


<p>当使用的列非严格的索引最左前缀时，可以想象，只有a加速了索引搜索，找到所有符合a条件的记录的之后只能顺序扫描检查c是否符合条件。所以相比没有索引时要快，但是慢于使用严格索引最左前缀时的速度。</p>
<pre class="code literal-block">[SQL]select * from test where a = 0 and c = 1;
Affected rows: 0
Time: 0.043s
</pre>


<p>当没有使用到a列作为条件时完全没法使用索引，甚至比没有索引时还要慢。因为建表的时候a在前，b、c在后，并且数据节点有序。在没有索引的测试中，InnoDB引擎到a不为0时自动停止搜索。而在这个例子中需要扫描全表找出满足符合条件的b、c，达到完全没法忍受的16秒。</p>
<pre class="code literal-block">[SQL]select * from test where b = 0 and c = 1;
Affected rows: 0
Time: 16.023s
</pre>


<h4>索引对排序效率的影响</h4>
<p>只要能用到索引，并且ORDER BY后面的列在索引中，则顺序还是倒序排序对性能无影响。因为叶子节点是个双向链表，倒序可以从后向前遍历，与顺序的代价相同。</p>
<pre class="code literal-block">[SQL]select * from test where a = 0 ORDER BY b;
Affected rows: 0
Time: 0.085s

[SQL]select * from test where a = 0 ORDER BY b DESC;
Affected rows: 0
Time: 0.089s
</pre>


<p>但是，当有两个字段排序的顺序不同时，叶子节点的有序性就无法用在排序中，必须读出所有叶子节点之后再按指定的字段进行一趟排序，所以速度就慢了下来。</p>
<pre class="code literal-block">[SQL]select * from test where a = 0 ORDER BY b DESC, c DESC;
Affected rows: 0
Time: 0.089s

[SQL]select * from test where a = 0 ORDER BY b ASC, c DESC;
Affected rows: 0
Time: 0.184s
</pre>


<p>同样，下面的例子中对索引左边的字段a进行范围选择的时候也没法运用索引，因为多个取值的a无法保证b和c字段有序，必须重新排序</p>
<pre class="code literal-block">[SQL]select * from test where a &lt;= 0 ORDER BY b;
Affected rows: 0
Time: 0.103s
</pre>


<p>所以，尽可能做到覆盖索引（即where，order by中用到的字段被索引覆盖），能利用索引加速搜索和排序。</p>
<hr>
<p>参考资料：</p>
<p>《高性能MySQL》，电子工业出版社，2010年1月</p>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/pythonla-ji-hui-shou-ji-zhi.html" class="u-url">Python垃圾回收机制</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/pythonla-ji-hui-shou-ji-zhi.html" rel="bookmark"><time class="published dt-published" datetime="2013-10-24T10:44:52+08:00" title="2013-10-24 10:44">2013-10-24 10:44</time></a></p>
                <p class="commentline">
        
    <a href="posts/pythonla-ji-hui-shou-ji-zhi.html#disqus_thread" data-disqus-identifier="cache/posts/pythonla-ji-hui-shou-ji-zhi.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>题记：我是来填坑的。。。</p>
<p>本文主要结合CPython源码分析一下Python的GC机制（面试的时候被问到这个问题，之前理解不深，答得不好，一波大坑啊。。。）</p>
<hr>
<p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p>
<h3>引用计数</h3>
<p>引用计数法在对象内部维护了一个被其他对象引用数的引用计数值，当这个引用计数值为0时，说明这个对象不再被其他对象引用，就可以被回收了。</p>
<p>结合源码来看，所有Python对象的头部包含了这样一个结构PyObject（相当于继承自PyObject）：</p>
<pre class="code literal-block"><span class="c1">// object.h</span>
<span class="k">struct</span> <span class="n">_object</span> <span class="p">{</span>
    <span class="n">Py_ssize_t</span> <span class="n">ob_refcnt</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">ob_type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyObject</span><span class="p">;</span>
</pre>


<p>ob_refcnt就是引用计数值。</p>
<p>例如，下面是int型对象的定义：</p>
<pre class="code literal-block"><span class="c1">// intobject.h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">PyObject_HEAD</span>
        <span class="kt">long</span> <span class="n">ob_ival</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyIntObject</span><span class="p">;</span>
</pre>


<p>引用计数法有很明显的优点：</p>
<ol>
<li>高效</li>
<li>运行期没有停顿</li>
<li>对象有确定的生命周期</li>
<li>易于实现</li>
</ol>
<p>原始的引用计数法也有明显的缺点：</p>
<ol>
<li>维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。</li>
<li>无法解决循环引用的问题。A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数都为1，但显然应该被回收。</li>
</ol>
<p>为了解决这两个致命弱点，Python又引入了以下两种GC机制。</p>
<h3>标记-清除</h3>
<p>“标记-清除”法是为了解决循环引用问题。可以包含其他对象引用的容器对象（如list, dict, set，甚至class）都可能产生循环引用，为此，在申请内存时，所有容器对象的头部又加上了<code>PyGC_Head</code>来实现“标记-清除”机制。</p>
<pre class="code literal-block"><span class="c1">// objimpl.h</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">_gc_head</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="k">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_next</span><span class="p">;</span>
        <span class="k">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_prev</span><span class="p">;</span>
        <span class="n">Py_ssize_t</span> <span class="n">gc_refs</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">gc</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">double</span> <span class="n">dummy</span><span class="p">;</span>  <span class="cm">/* force worst-case alignment */</span>
<span class="p">}</span> <span class="n">PyGC_Head</span><span class="p">;</span>
</pre>


<p>在为对象申请内存的时候，可以明显看到，实际申请的内存数量已经加上了PyGC_Head的大小</p>
<pre class="code literal-block"><span class="c1">// gcmodule.c</span>
<span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">_PyObject_GC_Malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">basicsize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="p">)</span><span class="n">PyObject_MALLOC</span><span class="p">(</span>
                <span class="k">sizeof</span><span class="p">(</span><span class="n">PyGC_Head</span><span class="p">)</span> <span class="o">+</span> <span class="n">basicsize</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">g</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>

    <span class="p">......</span>

    <span class="n">op</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>举例来说，从<code>list</code>对象的创建中，有如下主要逻辑：</p>
<pre class="code literal-block"><span class="c1">// listobject.c</span>
<span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyList_New</span><span class="p">(</span><span class="n">Py_ssize_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyListObject</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
    <span class="p">......</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">PyObject_GC_New</span><span class="p">(</span><span class="n">PyListObject</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PyList_Type</span><span class="p">);</span>
    <span class="p">......</span>
    <span class="n">_PyObject_GC_TRACK</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p><code>_PyObject_GC_TRACK</code>就将对象链接到了第0代对象集合中（后文详述分代回收）。</p>
<p>垃圾标记时，先将集合中对象的引用计数复制一份副本(以免在操作过程中破坏真实的引用计数值)：</p>
<pre class="code literal-block"><span class="c1">// gcmodule.c</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">update_refs</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">containers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">containers</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">gc</span> <span class="o">!=</span> <span class="n">containers</span><span class="p">;</span> <span class="n">gc</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">==</span> <span class="n">GC_REACHABLE</span><span class="p">);</span>
        <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ob_refcnt</span><span class="p">;</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>


<p>然后操作这个副本，遍历对象集合，将被引用对象的引用计数副本值减1：</p>
<pre class="code literal-block"><span class="c1">// gcmodule.c</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">subtract_refs</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">containers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">traverseproc</span> <span class="n">traverse</span><span class="p">;</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">containers</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">gc</span> <span class="o">!=</span> <span class="n">containers</span><span class="p">;</span> <span class="n">gc</span><span class="o">=</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">traverse</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_traverse</span><span class="p">;</span>
        <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">traverse</span><span class="p">(</span><span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">),</span>
                   <span class="p">(</span><span class="n">visitproc</span><span class="p">)</span><span class="n">visit_decref</span><span class="p">,</span>
                   <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>


<p>这个<code>traverse</code>是对象类型定义的函数，用来遍历对象，通过传入的回调函数<code>visit_decref</code>来操作引用计数副本。</p>
<p>例如<code>dict</code>就要在key和value上都用<code>visit_decref</code>操作一遍：</p>
<pre class="code literal-block"><span class="c1">// dictobject.c</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">dict_traverse</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_ssize_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">pk</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">pv</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">PyDict_Next</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pv</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">visit</span><span class="p">(</span><span class="n">pk</span><span class="p">);</span>
        <span class="n">visit</span><span class="p">(</span><span class="n">pv</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>然后根据引用计数副本值是否为0将集合内的对象分成两类，reachable和unreachable，其中unreachable是可以被回收的对象：</p>
<pre class="code literal-block"><span class="c1">// gcmodule.c</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">move_unreachable</span><span class="p">(</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">young</span><span class="p">,</span> <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">unreachable</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">gc</span> <span class="o">=</span> <span class="n">young</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">gc</span> <span class="o">!=</span> <span class="n">young</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyGC_Head</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">gc</span><span class="p">);</span>
            <span class="n">traverseproc</span> <span class="n">traverse</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_traverse</span><span class="p">;</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">GC_REACHABLE</span><span class="p">;</span>
            <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">traverse</span><span class="p">(</span><span class="n">op</span><span class="p">,</span>
                            <span class="p">(</span><span class="n">visitproc</span><span class="p">)</span><span class="n">visit_reachable</span><span class="p">,</span>
                            <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">young</span><span class="p">);</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_next</span><span class="p">;</span>
            <span class="n">gc_list_move</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="n">unreachable</span><span class="p">);</span>
            <span class="n">gc</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">GC_TENTATIVELY_UNREACHABLE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">gc</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>


<p>在处理了weak reference和finalizer等琐碎细节后（本文不展开讲述，有兴趣的童鞋请参考python源码），就可以回收unreachable中的对象了。</p>
<h3>分代回收</h3>
<p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p>
<p>用来表示“代”的结构体是<code>gc_generation</code>， 包括了当前代链表表头、对象数量上限、当前对象数量：</p>
<pre class="code literal-block"><span class="c1">// gcmodule.c</span>
<span class="k">struct</span> <span class="n">gc_generation</span> <span class="p">{</span>
    <span class="n">PyGC_Head</span> <span class="n">head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">threshold</span><span class="p">;</span> <span class="cm">/* collection threshold */</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span> <span class="cm">/* count of allocations or collections of younger</span>
<span class="cm">              generations */</span>
<span class="p">};</span>
</pre>


<p>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。</p>
<pre class="code literal-block"><span class="cp">#define NUM_GENERATIONS 3</span>
<span class="cp">#define GEN_HEAD(n) (&amp;generations[n].head)</span>

<span class="cm">/* linked lists of container objects */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gc_generation</span> <span class="n">generations</span><span class="p">[</span><span class="n">NUM_GENERATIONS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/* PyGC_Head,               threshold,  count */</span>
    <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>   <span class="mi">700</span><span class="p">,</span>        <span class="mi">0</span><span class="p">},</span>
    <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>   <span class="mi">10</span><span class="p">,</span>     <span class="mi">0</span><span class="p">},</span>
    <span class="p">{{{</span><span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">GEN_HEAD</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span>   <span class="mi">10</span><span class="p">,</span>     <span class="mi">0</span><span class="p">},</span>
<span class="p">};</span>
</pre>


<p>新生成的对象会被加入第0代，前面<code>_PyObject_GC_Malloc</code>中省略的部分就是Python GC触发的时机。每新生成一个对象都会检查第0代有没有满，如果满了就开始着手进行垃圾回收：</p>
<pre class="code literal-block"> <span class="n">g</span><span class="o">-&gt;</span><span class="n">gc</span><span class="p">.</span><span class="n">gc_refs</span> <span class="o">=</span> <span class="n">GC_UNTRACKED</span><span class="p">;</span>
 <span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* number of allocated GC objects */</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&amp;&amp;</span>
     <span class="n">enabled</span> <span class="o">&amp;&amp;</span>
     <span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&amp;&amp;</span>
     <span class="o">!</span><span class="n">collecting</span> <span class="o">&amp;&amp;</span>
     <span class="o">!</span><span class="n">PyErr_Occurred</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">collecting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">collect_generations</span><span class="p">();</span>
          <span class="n">collecting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</pre>


<hr>
<p>参考资料：</p>
<ol>
<li>《Python源码剖析》，陈儒著，2008</li>
<li>Wikipedia - Reference counting: <a href="http://en.wikipedia.org/wiki/Reference_counting">http://en.wikipedia.org/wiki/Reference_counting</a>
</li>
<li>Wikipedia - Garbage collection: <a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</a>
</li>
</ol>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/li-yong-ld_preloadjin-xing-hook.html" class="u-url">利用LD_PRELOAD进行hook</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/li-yong-ld_preloadjin-xing-hook.html" rel="bookmark"><time class="published dt-published" datetime="2013-10-09T11:44:50+08:00" title="2013-10-09 11:44">2013-10-09 11:44</time></a></p>
                <p class="commentline">
        
    <a href="posts/li-yong-ld_preloadjin-xing-hook.html#disqus_thread" data-disqus-identifier="cache/posts/li-yong-ld_preloadjin-xing-hook.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>好久没玩hook这种猥琐的东西里，今天在Linux下体验了一把。</p>
<p>loader在进行动态链接的时候，会将有相同符号名的符号覆盖成LD_PRELOAD指定的so文件中的符号。换句话说，可以用我们自己的so库中的函数替换原来库里有的函数，从而达到hook的目的。这和Windows下通过修改import table来hook API很类似。相比较之下，LD_PRELOAD更方便了，都不用自己写代码了，系统的loader会帮我们搞定。但是LD_PRELOAD有个限制：只能hook动态链接的库，对静态链接的库无效，因为静态链接的代码都写到可执行文件里了嘛，没有坑让你填。</p>
<p>上代码</p>
<p>先是受害者，我们的主程序main.c，通过strcmp比较字符串是否相等：</p>
<pre class="code literal-block"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">"test"</span><span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Incorrect password</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Correct password</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>然后是用来hook的库hook.c：</p>
<pre class="code literal-block"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;dlfcn.h&gt;</span>

<span class="k">typedef</span> <span class="nf">int</span><span class="p">(</span><span class="o">*</span><span class="n">STRCMP</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">strcmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">STRCMP</span> <span class="n">old_strcmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">handle</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="s">"libc.so.6"</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
        <span class="n">old_strcmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">STRCMP</span><span class="p">)</span><span class="n">dlsym</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">"strcmp"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hack function invoked. s1=&lt;%s&gt; s2=&lt;%s&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">old_strcmp</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>
<span class="p">}</span>
</pre>


<p>因为hook的目标是strcmp，所以typedef了一个STRCMP函数指针。由于hook的目的是要控制函数行为，所以需要从原库libc.so.6中拿到“正版”strcmp指针，保存成old_strcmp以备调用。</p>
<p>Makefile：</p>
<pre class="code literal-block"><span class="nb">test</span>: main.c hook.so
    gcc -o <span class="nb">test </span>main.c

hook.so: hook.c
    gcc -fPIC -shared -o hook.so hook.c -ldl
</pre>


<p>执行：</p>
<pre class="code literal-block"><span class="nv">$ LD_PRELOAD</span><span class="o">=</span>./hook.so ./test 123
hack <span class="k">function</span> invoked. <span class="nv">s1</span><span class="o">=</span>&lt;123&gt; <span class="nv">s2</span><span class="o">=</span>&lt;<span class="nb">test</span>&gt;
Incorrect password

<span class="nv">$ LD_PRELOAD</span><span class="o">=</span>./hook.so ./test <span class="nb">test</span>
hack <span class="k">function</span> invoked. <span class="nv">s1</span><span class="o">=</span>&lt;<span class="nb">test</span>&gt; <span class="nv">s2</span><span class="o">=</span>&lt;<span class="nb">test</span>&gt;
Correct password
</pre>


<p>其中有一点不理解的是，<code>dlopen</code>打开libc.so.6能拿到“正版”strcmp地址，打开libc.so就是hook后的地址。照理说libc.so不是libc.so.6的一个软链吗？为什么结果会不一样嘞？</p>
<hr>
<p>参考资料：</p>
<p><a href="http://www.exploit-db.com/papers/13233/">Reverse Engineering with LD_PRELOAD</a></p>
</div>
    </div>
    </article><article class="blog-post h-entry post-text"><header><h2 class="p-name entry-title blog-post-title"><a href="posts/linuxxia-bian-yi-lian-jie-dong-tai-ku.html" class="u-url">Linux下编译链接动态库</a></h2>
        <div class="metadata blog-post-meta">
            <p class="byline author vcard"><span class="byline-name fn">hbprotoss</span></p>
            <p class="dateline"><a href="posts/linuxxia-bian-yi-lian-jie-dong-tai-ku.html" rel="bookmark"><time class="published dt-published" datetime="2013-10-08T09:18:31+08:00" title="2013-10-08 09:18">2013-10-08 09:18</time></a></p>
                <p class="commentline">
        
    <a href="posts/linuxxia-bian-yi-lian-jie-dong-tai-ku.html#disqus_thread" data-disqus-identifier="cache/posts/linuxxia-bian-yi-lian-jie-dong-tai-ku.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>记录下Linux下编译和链接动态库的过程。</p>
<h3>一、 编写动态库</h3>
<p>头文件so.h：  </p>
<pre class="code literal-block"><span class="cp">#ifndef  SO_H</span>
<span class="cp">#define  SO_H</span>

<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>


<span class="cp">#endif  </span><span class="cm">/*SO_H*/</span><span class="cp"></span>
</pre>


<p>实现文件so.c：</p>
<pre class="code literal-block"><span class="cp">#include "so.h"</span>

<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<h3>二、编译动态库</h3>
<pre class="code literal-block">gcc so.c -fPIC -shared -o libtest.so
</pre>


<p>解释一下各个参数含义：</p>
<ol>
<li>-fPIC：生成位置无关代码(<a href="http://en.wikipedia.org/wiki/Position-independent_code">Position Independent Code</a>)，只有生成PIC才能通过虚拟页映射达到可执行代码在进程间共享，从而节省内存的目的。</li>
<li>说明我们要生成的是动态库so(Shared Object)文件，从而进行动态链接。</li>
</ol>
<p>通过<code>nm -g libtest.so</code>可以看到，导出符号表中已经有<code>add</code>这个符号了：</p>
<pre class="code literal-block"><span class="nv">$ </span>nm -g libtest.so 
<span class="m">0000000000000670</span> T add
<span class="m">0000000000201030</span> B __bss_start
                 w __cxa_finalize@@GLIBC_2.2.5
<span class="m">0000000000201030</span> D _edata
<span class="m">0000000000201038</span> B _end
<span class="m">0000000000000684</span> T _fini
                 w __gmon_start__
<span class="m">0000000000000540</span> T _init
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
                 w _Jv_RegisterClasses
</pre>


<h3>三、使用动态库</h3>
<h4>1. 隐式链接(编译时链接)</h4>
<p>编写主程序main.c：</p>
<pre class="code literal-block"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include "so.h"</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>使用<code>gcc main.c -L. -ltest -o test</code>进行编译。</p>
<ul>
<li>-L：添加库文件的搜索路径</li>
<li>-l：指定需要链接的库。该名称是处在头lib和后缀.so中的名称，如上动态库libtest.so的l参数为-l test</li>
</ul>
<p>此时通过<code>readelf test -d</code>已经能看到生成的可执行文件test的Dynamic section里依赖libtest.so了</p>
<pre class="code literal-block"><span class="nv">$ </span>readelf <span class="nb">test</span> -d

Dynamic section at offset 0xe18 contains <span class="m">25</span> entries:
  Tag        Type                         Name/Value
 0x0000000000000001 <span class="o">(</span>NEEDED<span class="o">)</span>             Shared library: <span class="o">[</span>libtest.so<span class="o">]</span>
 0x0000000000000001 <span class="o">(</span>NEEDED<span class="o">)</span>             Shared library: <span class="o">[</span>libc.so.6<span class="o">]</span>
......
</pre>


<p>dynamic symbols中也有一个undefined symbol(add)</p>
<pre class="code literal-block"><span class="nv">$ </span>nm -D <span class="nb">test </span>
<span class="nb">                 </span>U add
<span class="m">0000000000601048</span> B __bss_start
<span class="m">0000000000601048</span> D _edata
<span class="m">0000000000601050</span> B _end
00000000004007b4 T _fini
                 w __gmon_start__
<span class="m">0000000000400578</span> T _init
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
                 w _Jv_RegisterClasses
                 U __libc_start_main
                 U <span class="nb">printf</span>
</pre>


<p>在执行隐式链接的程序之前要注意设置<code>LD_LIBRARY_PATH</code>环境变量，或者把前面生成的libtest.so复制到系统路径下，否则会找不到动态库。</p>
<pre class="code literal-block"><span class="nv">$ </span>./test 
./test: error <span class="k">while</span> loading shared libraries: libtest.so: cannot open shared object file: No such file or directory

<span class="nv">$ </span><span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span>.

<span class="nv">$ </span>./test 
3
</pre>


<h4>2. 显式链接(运行时链接)</h4>
<p>编写主程序dyn_main.c</p>
<pre class="code literal-block"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;dlfcn.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">dl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">add</span><span class="p">)(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">dl</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span> <span class="s">"./libtest.so"</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">dl</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"so loading error.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">add</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span><span class="n">dlsym</span><span class="p">(</span><span class="n">dl</span><span class="p">,</span> <span class="s">"add"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">dlerror</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"fun load error.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>使用<code>gcc dyn_main.c -ldl -o dyn_test</code>编译。</p>
<p>这时通过<code>readelf dyn_test -d</code>可以发现，dyn_test不依赖libtest.so：</p>
<pre class="code literal-block"><span class="nv">$ </span>readelf dyn_test -d

Dynamic section at offset 0xe18 contains <span class="m">25</span> entries:
  Tag        Type                         Name/Value
 0x0000000000000001 <span class="o">(</span>NEEDED<span class="o">)</span>             Shared library: <span class="o">[</span>libdl.so.2<span class="o">]</span>
 0x0000000000000001 <span class="o">(</span>NEEDED<span class="o">)</span>             Shared library: <span class="o">[</span>libc.so.6<span class="o">]</span>
......
</pre>


<p>dyn_test的dynamic symbols中也没有add：</p>
<pre class="code literal-block"><span class="nv">$ </span>nm -D dyn_test 
                 U dlerror
                 U dlopen
                 U dlsym
                 w __gmon_start__
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
                 w _Jv_RegisterClasses
                 U __libc_start_main
                 U <span class="nb">printf</span>
<span class="nb">                 </span>U puts
</pre>


<p>运行程序也不需要设置<code>LD_LIBRARY_PATH</code>环境变量</p>
<pre class="code literal-block"><span class="nv">$ </span>./dyn_test 
3
</pre>


<hr>
<p>参考资料：</p>
<ol>
<li><a href="http://hi.baidu.com/linuxlife/item/ed8e5d0c6e86b491a2df4366">Linux动态库的编译与使用 转载</a></li>
<li><a href="http://os.51cto.com/art/201003/186246.htm">详细分析Linux动态库的使用方式</a></li>
<li><a href="http://stackoverflow.com/questions/34732/how-do-i-list-the-symbols-in-a-so-file">How do I list the symbols in a .so file</a></li>
<li><a href="http://stackoverflow.com/questions/10480657/import-names-in-elf-binary">Import names in ELF binary</a></li>
</ol>
</div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="index-1.html" rel="next">Older posts</a>
            </li>
        </ul></nav><script>var disqus_shortname="hbprotoss";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
            <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
                    <div class="sidebar-module sidebar-module-inset">
      <h4>About</h4>
      <p>踏歌长行</p>
      <p>梦想永在</p>
    </div>
    <div class="sidebar-module">
      <h4>Links</h4>
      <ol class="list-unstyled">
<li><a href="http://weibo.com/hbprotoss">Weibo</a></li>
        <li><a href="https://twitter.com/hbprotoss">Twitter</a></li>
        <li><a href="https://github.com/hbprotoss">GitHub</a></li>
      </ol>
<h4>友情链接</h4>
      <ol class="list-unstyled">
<li><a href="http://mckobe23.github.io">喀秋莎的技术博客</a></li>
      </ol>
</div>
    
            </div>
        <!--End of body content-->
        </div>
    </div>
</div>

<footer class="blog-footer" id="footer"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png"></a><br>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。
<br>Contents © 2016 <a href="mailto:">hbprotoss</a> - Powered by <a href="http://nikola.ralsina.com.ar">Nikola</a>
    
</footer><script src="assets/js/all-nocdn.js"></script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
