<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hbprotoss的博客 (Posts about 字符串)</title><link>http://hbprotoss.github.io/</link><description></description><atom:link href="http://hbprotoss.github.io/categories/zi-fu-chuan.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Mon, 23 Apr 2018 13:12:10 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>通俗演绎KMP</title><link>http://hbprotoss.github.io/posts/tong-su-yan-yi-kmp.html</link><dc:creator>hbprotoss</dc:creator><description>&lt;div&gt;&lt;p&gt;最近要实现关键字过滤功能，小看了一些经典的字符串匹配算法。&lt;br&gt;
本文要介绍的是KMP算法（&lt;strong&gt;Knuth–Morris–Pratt Algorithm&lt;/strong&gt;）,那个Knuth应该再熟悉不过了。  &lt;/p&gt;
&lt;p&gt;KMP算法是从朴素匹配算法改进而来。回忆一下朴素的匹配算法是怎么完成字符串的匹配的呢？&lt;br&gt;
1. 将原串和模式串左对齐，然后一位一位比较，直到有一个字符不匹配&lt;br&gt;
&lt;img alt="KMP1.png" src="http://hbprotoss.github.io/galleries/KMP/KMP1.png" title=""&gt;&lt;br&gt;
2. 发现第二位的B和C不匹配，模式串右移一位&lt;br&gt;
&lt;img alt="KMP2.png" src="http://hbprotoss.github.io/galleries/KMP/KMP2.png" title=""&gt;&lt;br&gt;
3. 重复这个流程，直到找到完全匹配的子串或者匹配失败。&lt;/p&gt;
&lt;p&gt;但这过程中显然有多比较的地方。如，原串为ABCDEABCDF，模式串为ABCDF。第一轮可以发现E和F不匹配&lt;br&gt;
&lt;img alt="KMP3.png" src="http://hbprotoss.github.io/galleries/KMP/KMP3.png" title=""&gt;&lt;br&gt;
很显然右移一位必定不匹配，这时模式串可以直接右移4位跳过ABCD，从E开始再次比较&lt;br&gt;
&lt;img alt="KMP4.png" src="http://hbprotoss.github.io/galleries/KMP/KMP4.png" title=""&gt;  &lt;/p&gt;
&lt;p&gt;那是不是跳过的长度就是前面相同部分的长度呢？其实不是这样的，这种直接跳过前面相同部分的做法在某些情况下会有问题。如，原串为ABCDABCDABF，模式串为ABCDABF，直接跳过相同部分就会遗漏匹配的串&lt;br&gt;
&lt;img alt="KMP5.png" src="http://hbprotoss.github.io/galleries/KMP/KMP5.png" title=""&gt;&lt;br&gt;
所以跳过的长度并不是前面完全匹配的部分，可以跳过的长度一般存储在模式串的partial match table中，即KMP算法需要对模式串进行预处理。&lt;/p&gt;
&lt;p&gt;先来看看这个partial match table在跳过的过程中是怎么用的，然后再来考察计算partial match table的算法。&lt;br&gt;
ABCDABF的partial match table如下：&lt;br&gt;
&lt;img alt="KMP6.png" src="http://hbprotoss.github.io/galleries/KMP/KMP6.png" title=""&gt;&lt;br&gt;
可以跳过的长度 = 当前已匹配长度 - 最后一个字母在partial match table中的值。例如：&lt;br&gt;
&lt;img alt="KMP7.png" src="http://hbprotoss.github.io/galleries/KMP/KMP7.png" title=""&gt;&lt;br&gt;
当发现C和F不匹配时，根据公式，当前已匹配串ABCDAB长度为6, 最后一个字母B在partial match table中的对应值为2，所以可以跳过的长度 = 6 - 2 = 4，即：&lt;br&gt;
&lt;img alt="KMP8.png" src="http://hbprotoss.github.io/galleries/KMP/KMP8.png" title=""&gt;&lt;br&gt;
这样就能正确匹配了。&lt;/p&gt;
&lt;p&gt;partial match table中每个位置i记录的其实就是从0到i的子串中，同时出现在子串前缀和后缀中的最大长度。还是以上面那个例子为例：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A没有前缀或后缀，所以长度为0&lt;/li&gt;
&lt;li&gt;AB前缀为A，后缀为B，没有相同部分，长度为0&lt;/li&gt;
&lt;li&gt;ABC前缀为A、AB，后缀为BC、C，没有相同部分，长度为0&lt;/li&gt;
&lt;li&gt;ABCD前缀为A、AB、ABC，后缀为BCD、CD、D，没有相同部分，长度为0&lt;/li&gt;
&lt;li&gt;ABCDA前缀为A、AB、ABC、ABCD，后缀为BCDA、CDA、DA、A，相同部分为A，长度为1&lt;/li&gt;
&lt;li&gt;ABCDAB前缀为A、AB、ABC、ABCD、ABCDA，后缀为BCDAB、CDAB、DAB、AB、B，相同部分为AB，长度为2&lt;/li&gt;
&lt;li&gt;ABCDABF前缀为A、AB、ABC、ABCD、ABCDA、ABCDAB，后缀为BCDABF、BCDAB、CDAB、DAB、AB、B，没有相同部分，长度为0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体代码参考&lt;a href="https://github.com/hbprotoss/codejam/blob/master/kmp.py"&gt;https://github.com/hbprotoss/codejam/blob/master/kmp.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全文完。&lt;/p&gt;&lt;/div&gt;</description><category>字符串</category><category>算法</category><guid>http://hbprotoss.github.io/posts/tong-su-yan-yi-kmp.html</guid><pubDate>Tue, 07 May 2013 12:09:38 GMT</pubDate></item></channel></rss>